(function() {
  window.example_list = [
    {
      title: '--- select example ---',
      code: ''
    }, {
      title: 'int arithmetic',
      code: 'pragma solidity ^0.5.11;\n\ncontract Arith {\n  int public value;\n  \n  function arith() public returns (int ret_val) {\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    c = -c;\n    c = a + b;\n    c = a - b;\n    c = a * b;\n    c = a / b;\n    return c;\n  }\n}'
    }, {
      title: 'uint arithmetic',
      code: 'pragma solidity ^0.5.11;\n\ncontract Arith {\n  uint public value;\n  \n  function arith() public returns (uint ret_val) {\n    uint a = 0;\n    uint b = 0;\n    uint c = 0;\n    c = a + b;\n    c = a * b;\n    c = a / b;\n    c = a | b;\n    c = a & b;\n    c = a ^ b;\n    return c;\n  }\n}'
    }, {
      title: '--- control flow ---',
      code: ''
    }, {
      title: 'if',
      code: 'pragma solidity ^0.5.11;\n\ncontract Ifer {\n  uint public value;\n  \n  function ifer() public returns (uint) {\n    uint x = 6;\n\n    if (x == 5) {\n        x += 1;\n    }\n    else {\n        x += 10;\n    }\n\n    return x;\n  }\n}'
    }, {
      title: 'for',
      code: 'pragma solidity ^0.5.11;\n\ncontract Forer {\n  uint public value;\n  \n  function forer() public returns (uint ret_val) {\n    uint y = 0;\n    for (uint i=0; i<5; i+=1) {\n        y += 1;\n    }\n    return y;\n  }\n} '
    }, {
      title: 'while',
      code: 'pragma solidity ^0.5.11;\n\ncontract Whiler {\n  uint public value;\n  \n  function whiler() public returns (uint ret_val) {\n    uint y = 0;\n    while (y != 2) {\n        y += 1;\n    }\n    return y;\n  }\n} '
    }, {
      title: '--- function capabilities ---',
      code: ''
    }, {
      title: 'fn call',
      code: 'pragma solidity ^0.5.11;\n\ncontract Fn_call {\n  int public value;\n  \n  function fn1(int a) public returns (int ret_val) {\n    value += 1;\n    return a;\n  }\n  function fn2() public returns (int ret_val) {\n    fn1(1);\n    int res = 1;\n    return res;\n  }\n}'
    }, {
      title: '--- real-world examples ---',
      code: ''
    }, {
      title: 'simplecoin',
      code: 'pragma solidity ^0.5.11;\n\ncontract Coin {\n    address minter;\n    mapping (address => uint) balances;\n    \n    constructor() public {\n        minter = msg.sender;\n    }\n    function mint(address owner, uint amount) public {\n        if (msg.sender == minter) {\n            balances[owner] += amount;\n        }\n    }\n    function send(address receiver, uint amount) public {\n        if (balances[msg.sender] >= amount) {\n            balances[msg.sender] -= amount;\n            balances[receiver] += amount;\n        }\n    }\n    function queryBalance(address addr) public view returns (uint balance) {\n        return balances[addr];\n    }\n}'
    }, {
      title: 'AtomicSwap',
      code: 'pragma solidity ^0.4.18;\n\ncontract AtomicSwapEther {\n\n  struct Swap {\n    uint256 timelock;\n    uint256 value;\n    address ethTrader;\n    address withdrawTrader;\n    bytes32 secretLock;\n    bytes secretKey;\n  }\n\n  enum States {\n    INVALID,\n    OPEN,\n    CLOSED,\n    EXPIRED\n  }\n\n  mapping (bytes32 => Swap) private swaps;\n  mapping (bytes32 => States) private swapStates;\n\n  event Open(bytes32 _swapID, address _withdrawTrader,bytes32 _secretLock);\n  event Expire(bytes32 _swapID);\n  event Close(bytes32 _swapID, bytes _secretKey);\n\n  modifier onlyInvalidSwaps(bytes32 _swapID) {\n    require (swapStates[_swapID] == States.INVALID);\n    _;\n  }\n\n  modifier onlyOpenSwaps(bytes32 _swapID) {\n    require (swapStates[_swapID] == States.OPEN);\n    _;\n  }\n\n  modifier onlyClosedSwaps(bytes32 _swapID) {\n    require (swapStates[_swapID] == States.CLOSED);\n    _;\n  }\n\n  modifier onlyExpirableSwaps(bytes32 _swapID) {\n    require (now >= swaps[_swapID].timelock);\n    _;\n  }\n\n  modifier onlyWithSecretKey(bytes32 _swapID, bytes _secretKey) {\n    // TODO: Require _secretKey length to conform to the spec\n    require (swaps[_swapID].secretLock == sha256(_secretKey));\n    _;\n  }\n\n  function open(bytes32 _swapID, address _withdrawTrader, bytes32 _secretLock, uint256 _timelock) public onlyInvalidSwaps(_swapID) payable {\n    // Store the details of the swap.\n    Swap memory swap = Swap({\n      timelock: _timelock,\n      value: msg.value,\n      ethTrader: msg.sender,\n      withdrawTrader: _withdrawTrader,\n      secretLock: _secretLock,\n      secretKey: new bytes(0)\n    });\n    swaps[_swapID] = swap;\n    swapStates[_swapID] = States.OPEN;\n\n    // Trigger open event.\n    Open(_swapID, _withdrawTrader, _secretLock);\n  }\n\n  function close(bytes32 _swapID, bytes _secretKey) public onlyOpenSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) {\n    // Close the swap.\n    Swap memory swap = swaps[_swapID];\n    swaps[_swapID].secretKey = _secretKey;\n    swapStates[_swapID] = States.CLOSED;\n\n    // Transfer the ETH funds from this contract to the withdrawing trader.\n    swap.withdrawTrader.transfer(swap.value);\n\n    // Trigger close event.\n    Close(_swapID, _secretKey);\n  }\n\n  function expire(bytes32 _swapID) public onlyOpenSwaps(_swapID) onlyExpirableSwaps(_swapID) {\n    // Expire the swap.\n    Swap memory swap = swaps[_swapID];\n    swapStates[_swapID] = States.EXPIRED;\n\n    // Transfer the ETH value from this contract back to the ETH trader.\n    swap.ethTrader.transfer(swap.value);\n\n    // Trigger expire event.\n    Expire(_swapID);\n  }\n\n  function check(bytes32 _swapID) public view returns (uint256 timelock, uint256 value, address withdrawTrader, bytes32 secretLock) {\n    Swap memory swap = swaps[_swapID];\n    return (swap.timelock, swap.value, swap.withdrawTrader, swap.secretLock);\n  }\n\n  function checkSecretKey(bytes32 _swapID) public view onlyClosedSwaps(_swapID) returns (bytes secretKey) {\n    Swap memory swap = swaps[_swapID];\n    return swap.secretKey;\n  }\n}'
    }, {
      title: 'Dice',
      code: 'pragma solidity ^0.4.24;\n\n// * dice2.win - fair games that pay Ether. Version 5.\n//\n// * Ethereum smart contract, deployed at 0xD1CEeeeee83F8bCF3BEDad437202b6154E9F5405.\n//\n// * Uses hybrid commit-reveal + block hash random number generation that is immune\n//   to tampering by players, house and miners. Apart from being fully transparent,\n//   this also allows arbitrarily high bets.\n//\n// * Refer to https://dice2.win/whitepaper.pdf for detailed description and proofs.\n\ncontract Dice2Win {\n    /// *** Constants section\n\n    // Each bet is deducted 1% in favour of the house, but no less than some minimum.\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\n    // headroom for up to 10 Gwei prices.\n    uint256 constant HOUSE_EDGE_PERCENT = 1;\n    uint256 constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\n\n    // Bets lower than this amount do not participate in jackpot rolls (and are\n    // not deducted JACKPOT_FEE).\n    uint256 constant MIN_JACKPOT_BET = 0.1 ether;\n\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\n    uint256 constant JACKPOT_MODULO = 1000;\n    uint256 constant JACKPOT_FEE = 0.001 ether;\n\n    // There is minimum and maximum bets.\n    uint256 constant MIN_BET = 0.01 ether;\n    uint256 constant MAX_AMOUNT = 300000 ether;\n\n    // Modulo is a number of equiprobable outcomes in a game:\n    //  - 2 for coin flip\n    //  - 6 for dice\n    //  - 6*6 = 36 for double dice\n    //  - 100 for etheroll\n    //  - 37 for roulette\n    //  etc.\n    // It\'s called so because 256-bit entropy is treated like a huge integer and\n    // the remainder of its division by modulo is considered bet outcome.\n    uint256 constant MAX_MODULO = 100;\n\n    // For modulos below this threshold rolls are checked against a bit mask,\n    // thus allowing betting on any combination of outcomes. For example, given\n    // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\n    // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\n    // limit is used, allowing betting on any outcome in [0, N) range.\n    //\n    // The specific value is dictated by the fact that 256-bit intermediate\n    // multiplication result allows implementing population count efficiently\n    // for numbers that are up to 42 bits, and 40 is the highest multiple of\n    // eight below 42.\n    uint256 constant MAX_MASK_MODULO = 40;\n\n    // This is a check on bet mask overflow.\n    uint256 constant MAX_BET_MASK = 2**MAX_MASK_MODULO;\n\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\n    // past. Given that settleBet uses block hash of placeBet as one of\n    // complementary entropy sources, we cannot process bets older than this\n    // threshold. On rare occasions dice2.win croupier may fail to invoke\n    // settleBet in this timespan due to technical issues or extreme Ethereum\n    // congestion; such bets can be refunded via invoking refundBet.\n    uint256 constant BET_EXPIRATION_BLOCKS = 250;\n\n    // Some deliberately invalid address to initialize the secret signer with.\n    // Forces maintainers to invoke setSecretSigner before processing any bets.\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // Standard contract ownership transfer.\n    address public owner;\n    address private nextOwner;\n\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\n    uint256 public maxProfit;\n\n    // The address corresponding to a private key used to sign placeBet commits.\n    address public secretSigner;\n\n    // Accumulated jackpot fund.\n    uint128 public jackpotSize;\n\n    // Funds that are locked in potentially winning bets. Prevents contract from\n    // committing to bets it cannot pay out.\n    uint128 public lockedInBets;\n\n    // A structure representing a single bet.\n    struct Bet {\n        // Wager amount in wei.\n        uint256 amount;\n        // Modulo of a game.\n        uint8 modulo;\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\n        uint8 rollUnder;\n        // Block number of placeBet tx.\n        uint40 placeBlockNumber;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        uint40 mask;\n        // Address of a gambler, used to pay out winning bets.\n        address gambler;\n    }\n\n    // Mapping from commits to all currently active & processed bets.\n    mapping(uint256 => Bet) bets;\n\n    // Croupier account.\n    address public croupier;\n\n    // Events that are issued to make statistic recovery easier.\n    event FailedPayment(address indexed beneficiary, uint256 amount);\n    event Payment(address indexed beneficiary, uint256 amount);\n    event JackpotPayment(address indexed beneficiary, uint256 amount);\n\n    // This event is emitted in placeBet to record commit in the logs.\n    event Commit(uint256 commit);\n\n    // Constructor. Deliberately does not take any parameters.\n    constructor() public {\n        owner = msg.sender;\n        secretSigner = DUMMY_ADDRESS;\n        croupier = DUMMY_ADDRESS;\n    }\n\n    // Standard modifier on methods invokable only by contract owner.\n    modifier onlyOwner {\n        require(msg.sender == owner, "OnlyOwner methods called by non-owner.");\n        _;\n    }\n\n    // Standard modifier on methods invokable only by contract owner.\n    modifier onlyCroupier {\n        require(\n            msg.sender == croupier,\n            "OnlyCroupier methods called by non-croupier."\n        );\n        _;\n    }\n\n    // Standard contract ownership transfer implementation,\n    function approveNextOwner(address _nextOwner) external onlyOwner {\n        require(_nextOwner != owner, "Cannot approve current owner.");\n        nextOwner = _nextOwner;\n    }\n\n    function acceptNextOwner() external {\n        require(\n            msg.sender == nextOwner,\n            "Can only accept preapproved new owner."\n        );\n        owner = nextOwner;\n    }\n\n    // Fallback function deliberately left empty. It\'s primary use case\n    // is to top up the bank roll.\n    function() public payable {}\n\n    // See comment for "secretSigner" variable.\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\n        secretSigner = newSecretSigner;\n    }\n\n    // Change the croupier address.\n    function setCroupier(address newCroupier) external onlyOwner {\n        croupier = newCroupier;\n    }\n\n    // Change max bet reward. Setting this to zero effectively disables betting.\n    function setMaxProfit(uint256 _maxProfit) public onlyOwner {\n        require(_maxProfit < MAX_AMOUNT, "maxProfit should be a sane number.");\n        maxProfit = _maxProfit;\n    }\n\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\n    function increaseJackpot(uint256 increaseAmount) external onlyOwner {\n        require(\n            increaseAmount <= address(this).balance,\n            "Increase amount larger than balance."\n        );\n        require(\n            jackpotSize + lockedInBets + increaseAmount <=\n                address(this).balance,\n            "Not enough funds."\n        );\n        jackpotSize += uint128(increaseAmount);\n    }\n\n    // Funds withdrawal to cover costs of dice2.win operation.\n    function withdrawFunds(address beneficiary, uint256 withdrawAmount)\n        external\n        onlyOwner\n    {\n        require(\n            withdrawAmount <= address(this).balance,\n            "Increase amount larger than balance."\n        );\n        require(\n            jackpotSize + lockedInBets + withdrawAmount <=\n                address(this).balance,\n            "Not enough funds."\n        );\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount);\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function kill() external onlyOwner {\n        require(\n            lockedInBets == 0,\n            "All bets should be processed (settled or refunded) before self-destruct."\n        );\n        selfdestruct(owner);\n    }\n\n    /// *** Betting logic\n\n    // Bet states:\n    //  amount == 0 && gambler == 0 - \'clean\' (can place a bet)\n    //  amount != 0 && gambler != 0 - \'active\' (can be settled or refunded)\n    //  amount == 0 && gambler != 0 - \'processed\' (can clean storage)\n    //\n    //  NOTE: Storage cleaning is not implemented in this contract version; it will be added\n    //        with the next upgrade to prevent polluting Ethereum state with expired bets.\n\n    // Bet placing transaction - issued by the player.\n    //  betMask         - bet outcomes bit mask for modulo <= MAX_MASK_MODULO,\n    //                    [0, betMask) for larger modulos.\n    //  modulo          - game modulo.\n    //  commitLastBlock - number of the maximum block where "commit" is still considered valid.\n    //  commit          - Keccak256 hash of some secret "reveal" random number, to be supplied\n    //                    by the dice2.win croupier bot in the settleBet transaction. Supplying\n    //                    "commit" ensures that "reveal" cannot be changed behind the scenes\n    //                    after placeBet have been mined.\n    //  r, s            - components of ECDSA signature of (commitLastBlock, commit). v is\n    //                    guaranteed to always equal 27.\n    //\n    // Commit, being essentially random 256-bit number, is used as a unique bet identifier in\n    // the \'bets\' mapping.\n    //\n    // Commits are signed with a block limit to ensure that they are used at most once - otherwise\n    // it would be possible for a miner to place a bet with a known commit/reveal pair and tamper\n    // with the blockhash. Croupier guarantees that commitLastBlock will always be not greater than\n    // placeBet block number plus BET_EXPIRATION_BLOCKS. See whitepaper for details.\n    function placeBet(\n        uint256 betMask,\n        uint256 modulo,\n        uint256 commitLastBlock,\n        uint256 commit,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        // Check that the bet is in \'clean\' state.\n        Bet storage bet = bets[commit];\n        require(bet.gambler == address(0), "Bet should be in a \'clean\' state.");\n\n        // Validate input data ranges.\n        uint256 amount = msg.value;\n        require(\n            modulo > 1 && modulo <= MAX_MODULO,\n            "Modulo should be within range."\n        );\n        require(\n            amount >= MIN_BET && amount <= MAX_AMOUNT,\n            "Amount should be within range."\n        );\n        require(\n            betMask > 0 && betMask < MAX_BET_MASK,\n            "Mask should be within range."\n        );\n\n        // Check that commit is valid - it has not expired and its signature is valid.\n        require(block.number <= commitLastBlock, "Commit has expired.");\n        bytes32 signatureHash = keccak256(\n            abi.encodePacked(uint40(commitLastBlock), commit)\n        );\n        require(\n            secretSigner == ecrecover(signatureHash, 27, r, s),\n            "ECDSA signature is not valid."\n        );\n\n        uint256 rollUnder;\n        uint256 mask;\n\n        if (modulo <= MAX_MASK_MODULO) {\n            // Small modulo games specify bet outcomes via bit mask.\n            // rollUnder is a number of 1 bits in this mask (population count).\n            // This magic looking formula is an efficient way to compute population\n            // count on EVM for numbers below 2**40. For detailed proof consult\n            // the dice2.win whitepaper.\n            rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\n            mask = betMask;\n        } else {\n            // Larger modulos specify the right edge of half-open interval of\n            // winning bet outcomes.\n            require(\n                betMask > 0 && betMask <= modulo,\n                "High modulo range, betMask larger than modulo."\n            );\n            rollUnder = betMask;\n        }\n\n        // Winning amount and jackpot increase.\n        uint256 possibleWinAmount;\n        uint256 jackpotFee;\n\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(\n            amount,\n            modulo,\n            rollUnder\n        );\n\n        // Enforce max profit limit.\n        require(\n            possibleWinAmount <= amount + maxProfit,\n            "maxProfit limit violation."\n        );\n\n        // Lock funds.\n        lockedInBets += uint128(possibleWinAmount);\n        jackpotSize += uint128(jackpotFee);\n\n        // Check whether contract has enough funds to process this bet.\n        require(\n            jackpotSize + lockedInBets <= address(this).balance,\n            "Cannot afford to lose this bet."\n        );\n\n        // Record commit in logs.\n        emit Commit(commit);\n\n        // Store bet parameters on blockchain.\n        bet.amount = amount;\n        bet.modulo = uint8(modulo);\n        bet.rollUnder = uint8(rollUnder);\n        bet.placeBlockNumber = uint40(block.number);\n        bet.mask = uint40(mask);\n        bet.gambler = msg.sender;\n    }\n\n    // This is the method used to settle 99% of bets. To process a bet with a specific\n    // "commit", settleBet should supply a "reveal" number that would Keccak256-hash to\n    // "commit". "blockHash" is the block hash of placeBet block as seen by croupier; it\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\n    function settleBet(uint256 reveal, bytes32 blockHash)\n        external\n        onlyCroupier\n    {\n        uint256 commit = uint256(keccak256(abi.encodePacked(reveal)));\n\n        Bet storage bet = bets[commit];\n        uint256 placeBlockNumber = bet.placeBlockNumber;\n\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\n        require(\n            block.number > placeBlockNumber,\n            "settleBet in the same block as placeBet, or before."\n        );\n        require(\n            block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS,\n            "Blockhash can\'t be queried by EVM."\n        );\n        require(blockhash(placeBlockNumber) == blockHash);\n\n        // Settle bet using reveal and blockHash as entropy sources.\n        settleBetCommon(bet, reveal, blockHash);\n    }\n\n    // This method is used to settle a bet that was mined into an uncle block. At this\n    // point the player was shown some bet outcome, but the blockhash at placeBet height\n    // is different because of Ethereum chain reorg. We supply a full merkle proof of the\n    // placeBet transaction receipt to provide untamperable evidence that uncle block hash\n    // indeed was present on-chain at some point.\n    function settleBetUncleMerkleProof(\n        uint256 reveal,\n        uint40 canonicalBlockNumber\n    ) external onlyCroupier {\n        // "commit" for bet settlement can only be obtained by hashing a "reveal".\n        uint256 commit = uint256(keccak256(abi.encodePacked(reveal)));\n\n        Bet storage bet = bets[commit];\n\n        // Check that canonical block hash can still be verified.\n        require(\n            block.number <= canonicalBlockNumber + BET_EXPIRATION_BLOCKS,\n            "Blockhash can\'t be queried by EVM."\n        );\n\n        // Verify placeBet receipt.\n        requireCorrectReceipt(4 + 32 + 32 + 4);\n\n        // Reconstruct canonical & uncle block hashes from a receipt merkle proof, verify them.\n        bytes32 canonicalHash;\n        bytes32 uncleHash;\n        (canonicalHash, uncleHash) = verifyMerkleProof(commit, 4 + 32 + 32);\n        require(blockhash(canonicalBlockNumber) == canonicalHash);\n\n        // Settle bet using reveal and uncleHash as entropy sources.\n        settleBetCommon(bet, reveal, uncleHash);\n    }\n\n    // Common settlement code for settleBet & settleBetUncleMerkleProof.\n    function settleBetCommon(\n        Bet storage bet,\n        uint256 reveal,\n        bytes32 entropyBlockHash\n    ) private {\n        // Fetch bet parameters into local variables (to save gas).\n        uint256 amount = bet.amount;\n        uint256 modulo = bet.modulo;\n        uint256 rollUnder = bet.rollUnder;\n        address gambler = bet.gambler;\n\n        // Check that bet is in \'active\' state.\n        require(amount != 0, "Bet should be in an \'active\' state");\n\n        // Move bet into \'processed\' state already.\n        bet.amount = 0;\n\n        // The RNG - combine "reveal" and blockhash of placeBet using Keccak256. Miners\n        // are not aware of "reveal" and cannot deduce it from "commit" (as Keccak256\n        // preimage is intractable), and house is unable to alter the "reveal" after\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\n\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\n        uint256 dice = uint256(entropy) % modulo;\n\n        uint256 diceWinAmount;\n        uint256 _jackpotFee;\n        (diceWinAmount, _jackpotFee) = getDiceWinAmount(\n            amount,\n            modulo,\n            rollUnder\n        );\n\n        uint256 diceWin = 0;\n        uint256 jackpotWin = 0;\n\n        // Determine dice outcome.\n        if (modulo <= MAX_MASK_MODULO) {\n            // For small modulo games, check the outcome against a bit mask.\n            if ((2**dice) & bet.mask != 0) {\n                diceWin = diceWinAmount;\n            }\n\n        } else {\n            // For larger modulos, check inclusion into half-open interval.\n            if (dice < rollUnder) {\n                diceWin = diceWinAmount;\n            }\n\n        }\n\n        // Unlock the bet amount, regardless of the outcome.\n        lockedInBets -= uint128(diceWinAmount);\n\n        // Roll for a jackpot (if eligible).\n        if (amount >= MIN_JACKPOT_BET) {\n            // The second modulo, statistically independent from the "main" dice roll.\n            // Effectively you are playing two games at once!\n            uint256 jackpotRng = (uint256(entropy) / modulo) % JACKPOT_MODULO;\n\n            // Bingo!\n            if (jackpotRng == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n        }\n\n        // Log jackpot win.\n        if (jackpotWin > 0) {\n            emit JackpotPayment(gambler, jackpotWin);\n        }\n\n        // Send the funds to gambler.\n        sendFunds(\n            gambler,\n            diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\n            diceWin\n        );\n    }\n\n    // Refund transaction - return the bet amount of a roll that was not processed in a\n    // due timeframe. Processing such blocks is not possible due to EVM limitations (see\n    // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\n    // in a situation like this, just contact the dice2.win support, however nothing\n    // precludes you from invoking this method yourself.\n    function refundBet(uint256 commit) external {\n        // Check that bet is in \'active\' state.\n        Bet storage bet = bets[commit];\n        uint256 amount = bet.amount;\n\n        require(amount != 0, "Bet should be in an \'active\' state");\n\n        // Check that bet has already expired.\n        require(\n            block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS,\n            "Blockhash can\'t be queried by EVM."\n        );\n\n        // Move bet into \'processed\' state, release funds.\n        bet.amount = 0;\n\n        uint256 diceWinAmount;\n        uint256 jackpotFee;\n        (diceWinAmount, jackpotFee) = getDiceWinAmount(\n            amount,\n            bet.modulo,\n            bet.rollUnder\n        );\n\n        lockedInBets -= uint128(diceWinAmount);\n        jackpotSize -= uint128(jackpotFee);\n\n        // Send the refund.\n        sendFunds(bet.gambler, amount, amount);\n    }\n\n    // Get the expected win amount after house edge is subtracted.\n    function getDiceWinAmount(uint256 amount, uint256 modulo, uint256 rollUnder)\n        private\n        pure\n        returns (uint256 winAmount, uint256 jackpotFee)\n    {\n        require(\n            0 < rollUnder && rollUnder <= modulo,\n            "Win probability out of range."\n        );\n\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\n\n        uint256 houseEdge = (amount * HOUSE_EDGE_PERCENT) / 100;\n\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\n        }\n\n        require(\n            houseEdge + jackpotFee <= amount,\n            "Bet doesn\'t even cover house edge."\n        );\n        winAmount = ((amount - houseEdge - jackpotFee) * modulo) / rollUnder;\n    }\n\n    // Helper routine to process the payment.\n    function sendFunds(\n        address beneficiary,\n        uint256 amount,\n        uint256 successLogAmount\n    ) private {\n        if (beneficiary.send(amount)) {\n            emit Payment(beneficiary, successLogAmount);\n        } else {\n            emit FailedPayment(beneficiary, amount);\n        }\n    }\n\n    // This are some constants making O(1) population count in placeBet possible.\n    // See whitepaper for intuition and proofs behind it.\n    uint256 constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\n    uint256 constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\n    uint256 constant POPCNT_MODULO = 0x3F;\n\n    // *** Merkle proofs.\n\n    // This helpers are used to verify cryptographic proofs of placeBet inclusion into\n    // uncle blocks. They are used to prevent bet outcome changing on Ethereum reorgs without\n    // compromising the security of the smart contract. Proof data is appended to the input data\n    // in a simple prefix length format and does not adhere to the ABI.\n    // Invariants checked:\n    //  - receipt trie entry contains a (1) successful transaction (2) directed at this smart\n    //    contract (3) containing commit as a payload.\n    //  - receipt trie entry is a part of a valid merkle proof of a block header\n    //  - the block header is a part of uncle list of some block on canonical chain\n    // The implementation is optimized for gas cost and relies on the specifics of Ethereum internal data structures.\n    // Read the whitepaper for details.\n\n    // Helper to verify a full merkle proof starting from some seedHash (usually commit). "offset" is the location of the proof\n    // beginning in the calldata.\n    function verifyMerkleProof(uint256 seedHash, uint256 offset)\n        private\n        pure\n        returns (bytes32 blockHash, bytes32 uncleHash)\n    {\n        // (Safe) assumption - nobody will write into RAM during this method invocation.\n        uint256 scratchBuf1;\n        assembly {\n            scratchBuf1 := mload(0x40)\n        }\n\n        uint256 uncleHeaderLength;\n        uint256 blobLength;\n        uint256 shift;\n        uint256 hashSlot;\n\n        // Verify merkle proofs up to uncle block header. Calldata layout is:\n        //  - 2 byte big-endian slice length\n        //  - 2 byte big-endian offset to the beginning of previous slice hash within the current slice (should be zeroed)\n        //  - followed by the current slice verbatim\n        for (; ; offset += blobLength) {\n            assembly {\n                blobLength := and(calldataload(sub(offset, 30)), 0xffff)\n            }\n            if (blobLength == 0) {\n                // Zero slice length marks the end of uncle proof.\n                break;\n            }\n\n            assembly {\n                shift := and(calldataload(sub(offset, 28)), 0xffff)\n            }\n            require(shift + 32 <= blobLength, "Shift bounds check.");\n\n            offset += 4;\n            assembly {\n                hashSlot := calldataload(add(offset, shift))\n            }\n            require(hashSlot == 0, "Non-empty hash slot.");\n\n            assembly {\n                calldatacopy(scratchBuf1, offset, blobLength)\n                mstore(add(scratchBuf1, shift), seedHash)\n                seedHash := sha3(scratchBuf1, blobLength)\n                uncleHeaderLength := blobLength\n            }\n        }\n\n        // At this moment the uncle hash is known.\n        uncleHash = bytes32(seedHash);\n\n        // Construct the uncle list of a canonical block.\n        uint256 scratchBuf2 = scratchBuf1 + uncleHeaderLength;\n        uint256 unclesLength;\n        assembly {\n            unclesLength := and(calldataload(sub(offset, 28)), 0xffff)\n        }\n        uint256 unclesShift;\n        assembly {\n            unclesShift := and(calldataload(sub(offset, 26)), 0xffff)\n        }\n        require(\n            unclesShift + uncleHeaderLength <= unclesLength,\n            "Shift bounds check."\n        );\n\n        offset += 6;\n        assembly {\n            calldatacopy(scratchBuf2, offset, unclesLength)\n        }\n        memcpy(scratchBuf2 + unclesShift, scratchBuf1, uncleHeaderLength);\n\n        assembly {\n            seedHash := sha3(scratchBuf2, unclesLength)\n        }\n\n        offset += unclesLength;\n\n        // Verify the canonical block header using the computed sha3Uncles.\n        assembly {\n            blobLength := and(calldataload(sub(offset, 30)), 0xffff)\n            shift := and(calldataload(sub(offset, 28)), 0xffff)\n        }\n        require(shift + 32 <= blobLength, "Shift bounds check.");\n\n        offset += 4;\n        assembly {\n            hashSlot := calldataload(add(offset, shift))\n        }\n        require(hashSlot == 0, "Non-empty hash slot.");\n\n        assembly {\n            calldatacopy(scratchBuf1, offset, blobLength)\n            mstore(add(scratchBuf1, shift), seedHash)\n\n            // At this moment the canonical block hash is known.\n            blockHash := sha3(scratchBuf1, blobLength)\n        }\n    }\n\n    // Helper to check the placeBet receipt. "offset" is the location of the proof beginning in the calldata.\n    // RLP layout: [triePath, str([status, cumGasUsed, bloomFilter, [[address, [topics], data]])]\n    function requireCorrectReceipt(uint256 offset) private view {\n        uint256 leafHeaderByte;\n        assembly {\n            leafHeaderByte := byte(0, calldataload(offset))\n        }\n\n        require(leafHeaderByte >= 0xf7, "Receipt leaf longer than 55 bytes.");\n        offset += leafHeaderByte - 0xf6;\n\n        uint256 pathHeaderByte;\n        assembly {\n            pathHeaderByte := byte(0, calldataload(offset))\n        }\n\n        if (pathHeaderByte <= 0x7f) {\n            offset += 1;\n\n        } else {\n            require(\n                pathHeaderByte >= 0x80 && pathHeaderByte <= 0xb7,\n                "Path is an RLP string."\n            );\n            offset += pathHeaderByte - 0x7f;\n        }\n\n        uint256 receiptStringHeaderByte;\n        assembly {\n            receiptStringHeaderByte := byte(0, calldataload(offset))\n        }\n        require(\n            receiptStringHeaderByte == 0xb9,\n            "Receipt string is always at least 256 bytes long, but less than 64k."\n        );\n        offset += 3;\n\n        uint256 receiptHeaderByte;\n        assembly {\n            receiptHeaderByte := byte(0, calldataload(offset))\n        }\n        require(\n            receiptHeaderByte == 0xf9,\n            "Receipt is always at least 256 bytes long, but less than 64k."\n        );\n        offset += 3;\n\n        uint256 statusByte;\n        assembly {\n            statusByte := byte(0, calldataload(offset))\n        }\n        require(statusByte == 0x1, "Status should be success.");\n        offset += 1;\n\n        uint256 cumGasHeaderByte;\n        assembly {\n            cumGasHeaderByte := byte(0, calldataload(offset))\n        }\n        if (cumGasHeaderByte <= 0x7f) {\n            offset += 1;\n\n        } else {\n            require(\n                cumGasHeaderByte >= 0x80 && cumGasHeaderByte <= 0xb7,\n                "Cumulative gas is an RLP string."\n            );\n            offset += cumGasHeaderByte - 0x7f;\n        }\n\n        uint256 bloomHeaderByte;\n        assembly {\n            bloomHeaderByte := byte(0, calldataload(offset))\n        }\n        require(\n            bloomHeaderByte == 0xb9,\n            "Bloom filter is always 256 bytes long."\n        );\n        offset += 256 + 3;\n\n        uint256 logsListHeaderByte;\n        assembly {\n            logsListHeaderByte := byte(0, calldataload(offset))\n        }\n        require(\n            logsListHeaderByte == 0xf8,\n            "Logs list is less than 256 bytes long."\n        );\n        offset += 2;\n\n        uint256 logEntryHeaderByte;\n        assembly {\n            logEntryHeaderByte := byte(0, calldataload(offset))\n        }\n        require(\n            logEntryHeaderByte == 0xf8,\n            "Log entry is less than 256 bytes long."\n        );\n        offset += 2;\n\n        uint256 addressHeaderByte;\n        assembly {\n            addressHeaderByte := byte(0, calldataload(offset))\n        }\n        require(addressHeaderByte == 0x94, "Address is 20 bytes long.");\n\n        uint256 logAddress;\n        assembly {\n            logAddress := and(\n                calldataload(sub(offset, 11)),\n                0xffffffffffffffffffffffffffffffffffffffff\n            )\n        }\n        require(logAddress == uint256(address(this)));\n    }\n\n    // Memory copy.\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Full 32 byte words\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}'
    }, {
      title: 'Creatures',
      code: 'pragma solidity ^0.4.16;\n\ncontract Permissions {\n    address ownerAddress;\n    address storageAddress;\n    address callerAddress;\n\n    function Permissions() public {\n        ownerAddress = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == ownerAddress);\n        _;\n    }\n\n    modifier onlyCaller() {\n        require(msg.sender == callerAddress);\n        _;\n    }\n\n    function getOwner() external view returns (address) {\n        return ownerAddress;\n    }\n\n    function getStorageAddress() external view returns (address) {\n        return storageAddress;\n    }\n\n    function getCaller() external view returns (address) {\n        return callerAddress;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner != address(0)) {\n            ownerAddress = newOwner;\n        }\n    }\n    function newStorage(address _new) external onlyOwner {\n        if (_new != address(0)) {\n            storageAddress = _new;\n        }\n    }\n    function newCaller(address _new) external onlyOwner {\n        if (_new != address(0)) {\n            callerAddress = _new;\n        }\n    }\n}\n\ncontract Creatures is Permissions {\n    struct Creature {\n        uint16 species;\n        uint8 subSpecies;\n        uint8 eyeColor;\n        uint64 timestamp;\n    }\n    Creature[] creatures;\n\n    mapping(uint256 => address) public creatureIndexToOwner;\n    mapping(address => uint256) ownershipTokenCount;\n\n    event CreateCreature(uint256 id, address indexed owner);\n    event Transfer(address _from, address _to, uint256 creatureID);\n\n    function add(\n        address _owner,\n        uint16 _species,\n        uint8 _subSpecies,\n        uint8 _eyeColor\n    ) external onlyCaller {\n        // do checks in caller function\n        Creature memory _creature = Creature({\n            species: _species,\n            subSpecies: _subSpecies,\n            eyeColor: _eyeColor,\n            timestamp: uint64(now)\n        });\n        uint256 newCreatureID = creatures.push(_creature) - 1;\n        transfer(0, _owner, newCreatureID);\n        CreateCreature(newCreatureID, _owner);\n    }\n    function getCreature(uint256 id)\n        external\n        view\n        returns (address, uint16, uint8, uint8, uint64)\n    {\n        Creature storage c = creatures[id];\n        address owner = creatureIndexToOwner[id];\n        return (owner, c.species, c.subSpecies, c.eyeColor, c.timestamp);\n    }\n    function transfer(address _from, address _to, uint256 _tokenId)\n        public\n        onlyCaller\n    {\n        // do checks in caller function\n        creatureIndexToOwner[_tokenId] = _to;\n        if (_from != address(0)) {\n            ownershipTokenCount[_from]--;\n        }\n        ownershipTokenCount[_to]++;\n        Transfer(_from, _to, _tokenId);\n    }\n}'
    }
  ];

}).call(this);

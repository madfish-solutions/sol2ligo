// Generated by IcedCoffeeScript 108.0.13
(function() {
  var bad_spec_id_trans_hash, last_bracket_state, module, number2bytes, some2nat, spec_id_trans_hash, spec_id_translate, string2bytes, translate_type, translate_var_name, type2default_value, walk, warning_once_hash;

  translate_var_name = window.translate_var_name.translate_var_name;
  module = this;

  module.warning_counter = 0;

  walk = null;

  this.bin_op_name_map = {
    ADD: "+",
    MUL: "*",
    DIV: "/",
    MOD: "mod",
    EQ: "=",
    NE: "=/=",
    GT: ">",
    LT: "<",
    GTE: ">=",
    LTE: "<=",
    POW: "LIGO_IMPLEMENT_ME_PLEASE_POW",
    BOOL_AND: "and",
    BOOL_OR: "or"
  };

  string2bytes = function(val) {
    var ch, ret, _i, _len;
    ret = ["0x"];
    for (_i = 0, _len = val.length; _i < _len; _i++) {
      ch = val[_i];
      ret.push(ch.charCodeAt(0).rjust(2, "0"));
    }
    if (ret.length === 1) {
      return "bytes_pack(unit)";
    }
    return ret.join("");
  };

  some2nat = function(val, type) {
    if (type.match(/^int\d{0,3}$/)) {
      val = "abs(" + val + ")";
    }
    if (type.match(/^byte[s]?\d{0,2}$/)) {
      val = "(case (bytes_unpack (" + val + ") : option (nat)) of | Some(a) -> a | None -> 0n end)";
    }
    return val;
  };

  number2bytes = function(val, precision) {
    var hex, i, ret, _i;
    if (precision == null) {
      precision = 32;
    }
    ret = [];
    for (i = _i = 0; 0 <= precision ? _i < precision : _i > precision; i = 0 <= precision ? ++_i : --_i) {
      hex = val & 0xFF;
      ret.push(hex.toString(16).rjust(2, "0"));
      val >>= 8;
    }
    ret.push("0x");
    ret.reverse();
    return ret.join("");
  };

  this.bin_op_name_cb_map = {
    ASSIGN: function(a, b, ctx, ast) {
      if (config.bytes_type_hash.hasOwnProperty(ast.a.type.main) && ast.b.type.main === "string" && ast.b.constructor.name === "Const") {
        b = string2bytes(ast.b.val);
      }
      return "" + a + " := " + b;
    },
    BIT_AND: function(a, b, ctx, ast) {
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      return "bitwise_and(" + a + ", " + b + ")";
    },
    BIT_OR: function(a, b, ctx, ast) {
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      return "bitwise_or(" + a + ", " + b + ")";
    },
    BIT_XOR: function(a, b, ctx, ast) {
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      return "bitwise_xor(" + a + ", " + b + ")";
    },
    SHR: function(a, b, ctx, ast) {
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      return "bitwise_lsr(" + a + ", " + b + ")";
    },
    SHL: function(a, b, ctx, ast) {
      a = some2nat(a, ast.a.type.main);
      b = some2nat(b, ast.b.type.main);
      return "bitwise_lsl(" + a + ", " + b + ")";
    },
    INDEX_ACCESS: function(a, b, ctx, ast) {
      var ret, val;
      return ret = ctx.lvalue ? "" + a + "[" + b + "]" : (val = type2default_value(ast.type, ctx), "(case " + a + "[" + b + "] of | None -> " + val + " | Some(x) -> x end)");
    },
    SUB: function(a, b, ctx, ast) {
      if (config.uint_type_hash.hasOwnProperty(ast.a.type.main) && config.uint_type_hash.hasOwnProperty(ast.b.type.main)) {
        return "abs(" + a + " - " + b + ")";
      } else {
        return "(" + a + " - " + b + ")";
      }
    }
  };

  this.un_op_name_cb_map = {
    MINUS: function(a) {
      return "-(" + a + ")";
    },
    PLUS: function(a) {
      return "+(" + a + ")";
    },
    BIT_NOT: function(a, ctx, ast) {
      if (!ast.type) {
        perr("WARNING BIT_NOT ( ~" + a + " ) translation can be incorrect");
        module.warning_counter++;
      }
      if (ast.type && config.uint_type_hash.hasOwnProperty(ast.type.main)) {
        return "abs(not (" + a + "))";
      } else {
        return "not (" + a + ")";
      }
    },
    BOOL_NOT: function(a) {
      return "not (" + a + ")";
    },
    RET_INC: function(a, ctx) {
      perr("RET_INC can have not fully correct implementation");
      module.warning_counter++;
      ctx.sink_list.push("" + a + " := " + a + " + 1");
      return ctx.trim_expr = "(" + a + " - 1)";
    },
    RET_DEC: function(a, ctx) {
      perr("RET_DEC can have not fully correct implementation");
      module.warning_counter++;
      ctx.sink_list.push("" + a + " := " + a + " - 1");
      return ctx.trim_expr = "(" + a + " + 1)";
    },
    INC_RET: function(a, ctx) {
      perr("INC_RET can have not fully correct implementation");
      module.warning_counter++;
      ctx.sink_list.push("" + a + " := " + a + " + 1");
      return ctx.trim_expr = "" + a;
    },
    DEC_RET: function(a, ctx) {
      perr("DEC_RET can have not fully correct implementation");
      module.warning_counter++;
      ctx.sink_list.push("" + a + " := " + a + " - 1");
      return ctx.trim_expr = "" + a;
    },
    DELETE: function(a, ctx, ast) {
      var bin_op_a, bin_op_b, nest_ctx;
      if (ast.a.constructor.name !== "Bin_op") {
        throw new Error("can't compile DELETE operation for non 'delete a[b]' like construction. Reason not Bin_op");
      }
      if (ast.a.op !== "INDEX_ACCESS") {
        throw new Error("can't compile DELETE operation for non 'delete a[b]' like construction. Reason not INDEX_ACCESS");
      }
      nest_ctx = ctx.mk_nest();
      bin_op_a = walk(ast.a.a, nest_ctx);
      bin_op_b = walk(ast.a.b, nest_ctx);
      return "remove " + bin_op_b + " from map " + bin_op_a;
    }
  };

  this.translate_type = translate_type = function(type, ctx) {
    var key, list, name, nest, v, value, _i, _len, _ref;
    switch (type.main) {
      case "bool":
        return "bool";
      case "string":
        return "string";
      case "address":
        return "address";
      case "built_in_op_list":
        return "list(operation)";
      case "array":
        nest = translate_type(type.nest_list[0], ctx);
        return "map(nat, " + nest + ")";
      case "tuple":
        list = [];
        _ref = type.nest_list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          list.push(translate_type(v, ctx));
        }
        return "(" + (list.join(' * ')) + ")";
      case "map":
        key = translate_type(type.nest_list[0], ctx);
        value = translate_type(type.nest_list[1], ctx);
        return "map(" + key + ", " + value + ")";
      case config.storage:
        return config.storage;
      default:
        if (ctx.type_decl_hash.hasOwnProperty(type.main)) {
          name = type.main.replace(/\./g, "_");
          name = translate_var_name(name, ctx);
          return name;
        } else if (type.main.match(/^byte[s]?\d{0,2}$/)) {
          return "bytes";
        } else if (config.uint_type_hash.hasOwnProperty(type.main)) {
          return "nat";
        } else if (config.int_type_hash.hasOwnProperty(type.main)) {
          return "int";
        } else {
          perr("CRITICAL WARNING. translate_type unknown solidity type '" + type + "'");
          return "UNKNOWN_TYPE_" + type;
        }
    }
  };

  this.type2default_value = type2default_value = function(type, ctx) {
    if (config.uint_type_hash.hasOwnProperty(type.main)) {
      return "0n";
    }
    if (config.int_type_hash.hasOwnProperty(type.main)) {
      return "0";
    }
    if (config.bytes_type_hash.hasOwnProperty(type.main)) {
      return "bytes_pack(unit)";
    }
    switch (type.main) {
      case "bool":
        return "False";
      case "address":
        return "(" + (JSON.stringify(config.default_address)) + " : address)";
      case "built_in_op_list":
        return "(nil: list(operation))";
      case "map":
      case "array":
        return "(map end : " + (translate_type(type, ctx)) + ")";
      case "string":
        return '""';
      default:
        perr("CRITICAL WARNING. type2default_value unknown solidity type '" + type + "'");
        return "UNKNOWN_TYPE_DEFAULT_VALUE_" + type;
    }
  };

  spec_id_trans_hash = {
    "now": "abs(now - (\"1970-01-01T00:00:00Z\": timestamp))",
    "msg.sender": "sender",
    "tx.origin": "source",
    "block.timestamp": "abs(now - (\"1970-01-01T00:00:00Z\": timestamp))",
    "msg.value": "(amount / 1mutez)",
    "abi.encodePacked": ""
  };

  bad_spec_id_trans_hash = {
    "block.coinbase": config.default_address,
    "block.difficulty": "0n",
    "block.gaslimit": "0n",
    "block.number": "0n",
    "msg.data": "bytes_pack(unit)",
    "msg.gas": "0n",
    "msg.sig": "bytes_pack(unit)",
    "tx.gasprice": "0n"
  };

  warning_once_hash = {};

  spec_id_translate = function(t, name) {
    var val;
    if (spec_id_trans_hash.hasOwnProperty(t)) {
      return spec_id_trans_hash[t];
    } else if (bad_spec_id_trans_hash.hasOwnProperty(t)) {
      val = bad_spec_id_trans_hash[t];
      if (!warning_once_hash.hasOwnProperty(t)) {
        warning_once_hash.hasOwnProperty[t] = true;
        perr("CRITICAL WARNING we don't have proper translation for ethereum '" + t + "', so it would be translated as '" + val + "'. That's incorrect");
      }
      return val;
    } else {
      return name;
    }
  };

  this.Gen_context = (function() {
    Gen_context.prototype.parent = null;

    Gen_context.prototype.next_gen = null;

    Gen_context.prototype.current_class = null;

    Gen_context.prototype.is_class_scope = false;

    Gen_context.prototype.lvalue = false;

    Gen_context.prototype.type_decl_hash = {};

    Gen_context.prototype.contract_var_hash = {};

    Gen_context.prototype.trim_expr = "";

    Gen_context.prototype.storage_sink_list = [];

    Gen_context.prototype.sink_list = [];

    Gen_context.prototype.type_decl_sink_list = [];

    Gen_context.prototype.tmp_idx = 0;

    function Gen_context() {
      this.type_decl_hash = {};
      this.contract_var_hash = {};
      this.storage_sink_list = [];
      this.sink_list = [];
      this.type_decl_sink_list = [];
    }

    Gen_context.prototype.mk_nest = function() {
      var t;
      t = new module.Gen_context;
      t.parent = this;
      t.current_class = this.current_class;
      obj_set(t.contract_var_hash, this.contract_var_hash);
      obj_set(t.type_decl_hash, this.type_decl_hash);
      t.type_decl_sink_list = this.type_decl_sink_list;
      return t;
    };

    return Gen_context;

  })();

  last_bracket_state = false;

  walk = function(root, ctx) {
    var a, arg, arg_jl, arg_list, args, aux, body, call_expr, case_scope, cb, chk_ret, code, cond, ctx_lvalue, decls, f, field_decl_jl, fn, i, idx, is_pure, jl, loc_code, msg, name, op, op_code, orig_ctx, prefix, ret, ret_jl, ret_type, scope, str, t, target_type, tmp_var, translated_type, type, type_decl, type_decl_jl, type_jl, type_list, v, val, _a, _aa, _b, _case, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len18, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _var, _w, _x, _y, _z;
    last_bracket_state = false;
    switch (root.constructor.name) {
      case "Scope":
        switch (root.original_node_type) {
          case "SourceUnit":
            jl = [];
            _ref = root.list;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              v = _ref[_i];
              code = walk(v, ctx);
              if (code) {
                jl.push(code);
              }
            }
            name = config.storage;
            jl.unshift("");
            if (ctx.storage_sink_list.length === 0) {
              ctx.storage_sink_list.push("" + config.empty_state + " : int;");
            }
            jl.unshift("type " + name + " is record\n  " + (join_list(ctx.storage_sink_list, '  ')) + "\nend;");
            ctx.storage_sink_list.clear();
            if (ctx.type_decl_sink_list.length) {
              type_decl_jl = [];
              _ref1 = ctx.type_decl_sink_list;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                type_decl = _ref1[_j];
                name = type_decl.name, field_decl_jl = type_decl.field_decl_jl;
                if (field_decl_jl.length === 0) {
                  field_decl_jl.push("" + config.empty_state + " : int;");
                }
                type_decl_jl.push("type " + name + " is record\n  " + (join_list(field_decl_jl, '  ')) + "\nend;\n");
              }
              jl.unshift("" + (join_list(type_decl_jl)));
            }
            return join_list(jl, "");
          default:
            if (!root.original_node_type) {
              jl = [];
              _ref2 = root.list;
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                v = _ref2[_k];
                code = walk(v, ctx);
                _ref3 = ctx.sink_list;
                for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                  loc_code = _ref3[_l];
                  if (!/;$/.test(loc_code)) {
                    loc_code += ";";
                  }
                  jl.push(loc_code);
                }
                ctx.sink_list.clear();
                if (ctx.trim_expr === code) {
                  ctx.trim_expr = "";
                  continue;
                }
                if (code) {
                  if (!/;$/.test(code)) {
                    code += ";";
                  }
                  jl.push(code);
                }
              }
              ret = jl.pop() || "";
              if (0 !== ret.indexOf("with")) {
                jl.push(ret);
                ret = "";
              }
              jl = jl.filter(function(t) {
                return t !== "";
              });
              if (!root.need_nest) {
                if (jl.length) {
                  body = join_list(jl, "");
                } else {
                  body = "";
                }
              } else {
                if (jl.length) {
                  body = "block {\n  " + (join_list(jl, '  ')) + "\n}";
                } else {
                  body = "block {\n  skip\n}";
                }
              }
              if (ret) {
                ret = " " + ret;
              }
              return "" + body + ret;
            } else {
              puts(root);
              throw new Error("Unknown root.original_node_type " + root.original_node_type);
            }
        }
        break;
      case "Var":
        name = root.name;
        if (name === "this") {
          return "";
        }
        if (root.name_translate) {
          name = translate_var_name(name, ctx);
        }
        if (ctx.contract_var_hash.hasOwnProperty(name)) {
          return "" + config.contract_storage + "." + name;
        } else {
          return spec_id_translate(root.name, name);
        }
        break;
      case "Const":
        if (!root.type) {
          puts(root);
          throw new Error("Can't type inference");
        }
        if (config.uint_type_hash.hasOwnProperty(root.type.main)) {
          return "" + root.val + "n";
        }
        switch (root.type.main) {
          case "bool":
            switch (root.val) {
              case "true":
                return "True";
              case "false":
                return "False";
              default:
                throw new Error("can't translate bool constant '" + root.val + "'");
            }
            break;
          case "number":
            perr("WARNING number constant passed to translation stage. That's type inference mistake");
            module.warning_counter++;
            return root.val;
          case "unsigned_number":
            return "" + root.val + "n";
          case "string":
            return JSON.stringify(root.val);
          default:
            if (config.bytes_type_hash.hasOwnProperty(root.type.main)) {
              return number2bytes(root.val, +root.type.main.replace(/bytes/, ''));
            } else {
              return root.val;
            }
        }
        break;
      case "Bin_op":
        ctx_lvalue = ctx.mk_nest();
        if (0 === root.op.indexOf("ASS")) {
          ctx_lvalue.lvalue = true;
        }
        _a = walk(root.a, ctx_lvalue);
        ctx.sink_list.append(ctx_lvalue.sink_list);
        _b = walk(root.b, ctx);
        return ret = (function() {
          if (op = module.bin_op_name_map[root.op]) {
            last_bracket_state = true;
            if (((root.a.type && root.a.type.main === 'bool') || (root.b.type && root.b.type.main === 'bool')) && (op === '>=' || op === '=/=' || op === '<=' || op === '>' || op === '<' || op === '=')) {
              switch (op) {
                case "=":
                  return "bitwise_not(bitwise_xor(" + _a + ", " + _b + "))";
                case "=/=":
                  return "bitwise_xor(" + _a + ", " + _b + ")";
                case ">":
                  return "(" + _a + " and not " + _b + ")";
                case "<":
                  return "((not " + _a + ") and " + _b + ")";
                case ">=":
                  return "(" + _a + " or not " + _b + ")";
                case "<=":
                  return "((not " + _a + ") or " + _b + ")";
                default:
                  return "(" + _a + " " + op + " " + _b + ")";
              }
            } else {
              return "(" + _a + " " + op + " " + _b + ")";
            }
          } else if (cb = module.bin_op_name_cb_map[root.op]) {
            return cb(_a, _b, ctx, root);
          } else {
            throw new Error("Unknown/unimplemented bin_op " + root.op);
          }
        })();
      case "Un_op":
        a = walk(root.a, ctx);
        if (cb = module.un_op_name_cb_map[root.op]) {
          return cb(a, ctx, root);
        } else {
          throw new Error("Unknown/unimplemented un_op " + root.op);
        }
        break;
      case "Field_access":
        t = walk(root.t, ctx);
        if (!root.t.type) {
          perr("CRITICAL WARNING some of types in Field_access aren't resolved. This can cause invalid code generated");
        } else {
          switch (root.t.type.main) {
            case "array":
              switch (root.name) {
                case "length":
                  return "size(" + t + ")";
                default:
                  throw new Error("unknown array field " + root.name);
              }
              break;
            case "bytes":
              switch (root.name) {
                case "length":
                  return "size(" + t + ")";
                default:
                  throw new Error("unknown array field " + root.name);
              }
          }
        }
        if (t === "") {
          return translate_var_name(root.name, ctx);
        }
        chk_ret = "" + t + "." + root.name;
        ret = "" + t + "." + (translate_var_name(root.name, ctx));
        if (root.t.constructor.name === "Var") {
          if ((_ref4 = ctx.type_decl_hash[root.t.name]) != null ? _ref4.is_library : void 0) {
            ret = translate_var_name("" + t + "_" + root.name, ctx);
          }
        }
        return spec_id_translate(chk_ret, ret);
      case "Fn_call":
        arg_list = [];
        _ref5 = root.arg_list;
        for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
          v = _ref5[_m];
          arg_list.push(walk(v, ctx));
        }
        if (root.fn.constructor.name === "Field_access") {
          t = walk(root.fn.t, ctx);
          if (root.fn.t.type) {
            switch (root.fn.t.type.main) {
              case "array":
                switch (root.fn.name) {
                  case "push":
                    tmp_var = "tmp_" + (ctx.tmp_idx++);
                    ctx.sink_list.push("const " + tmp_var + " : " + (translate_type(root.fn.t.type, ctx)) + " = " + t + ";");
                    return "" + tmp_var + "[size(" + tmp_var + ")] := " + arg_list[0];
                  default:
                    throw new Error("unknown array field function " + root.fn.name);
                }
                break;
              case "address":
                switch (root.fn.name) {
                  case "send":
                    perr("CRITICAL WARNING we don't check balance in send function. So runtime error will be ignored and no boolean return");
                    op_code = "transaction(unit, " + arg_list[0] + " * 1mutez, (get_contract(" + t + ") : contract(unit)))";
                    return "" + config.op_list + " := cons(" + op_code + ", " + config.op_list + ")";
                  case "transfer":
                    perr("CRITICAL WARNING we don't check balance in send function. So runtime error will be ignored and no throw");
                    op_code = "transaction(unit, " + arg_list[0] + " * 1mutez, (get_contract(" + t + ") : contract(unit)))";
                    return "" + config.op_list + " := cons(" + op_code + ", " + config.op_list + ")";
                  case "built_in_pure_callback":
                    ret_type = translate_type(root.arg_list[0].type, ctx);
                    ret = arg_list[0];
                    op_code = "transaction(" + ret + ", 0mutez, (get_contract(" + t + ") : contract(" + ret_type + ")))";
                    return "" + config.op_list + " := cons(" + op_code + ", " + config.op_list + ")";
                  default:
                    throw new Error("unknown address field " + root.fn.name);
                }
            }
          }
        }
        if (root.fn.constructor.name === "Var") {
          switch (root.fn.name) {
            case "require":
            case "require2":
            case "assert":
              cond = arg_list[0];
              str = arg_list[1] || '"require fail"';
              return "if " + cond + " then {skip} else failwith(" + str + ")";
            case "revert":
              str = arg_list[0] || '"revert"';
              return "failwith(" + str + ")";
            case "sha256":
              msg = arg_list[0];
              return "sha_256(" + msg + ")";
            case "sha3":
            case "keccak256":
              perr("CRITICAL WARNING " + root.fn.name + " hash function would be translated as sha_256. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#hash-functions");
              msg = arg_list[0];
              return "sha_256(" + msg + ")";
            case "ripemd160":
              perr("CRITICAL WARNING " + root.fn.name + " hash function would be translated as blake2b. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#hash-functions");
              msg = arg_list[0];
              return "blake2b(" + msg + ")";
            case "ecrecover":
              perr("WARNING ecrecover function is not present in LIGO. Read more: https://github.com/madfish-solutions/sol2ligo/wiki/Known-issues#hash-functions");
              fn = "ecrecover";
              break;
            default:
              name = root.fn.name;
              if (((_ref6 = ctx.current_class) != null ? _ref6.is_library : void 0) && ctx.current_class._prepared_field2type[name]) {
                name = "" + ctx.current_class.name + "_" + name;
                name = translate_var_name(name, ctx);
              } else {
                if (root.fn.name_translate) {
                  name = translate_var_name(name, ctx);
                }
              }
              fn = spec_id_translate(root.fn.name, name);
          }
        } else {
          fn = walk(root.fn, ctx);
        }
        if (((_ref7 = root.fn.type) != null ? _ref7.main : void 0) === "struct") {
          msg = "address contract to type_cast is not supported yet (we need enum action type for each contract)";
          perr("CRITICAL WARNING " + msg);
          return "(* " + msg + " *)";
        }
        is_pure = ((_ref8 = root.fn.type) != null ? _ref8.main : void 0) === "function2_pure";
        if (!is_pure) {
          arg_list.unshift(config.contract_storage);
          arg_list.unshift(config.op_list);
        }
        if (arg_list.length === 0) {
          arg_list.push("unit");
        }
        type_jl = [];
        _ref11 = ((_ref9 = root.fn.type) != null ? (_ref10 = _ref9.nest_list[1]) != null ? _ref10.nest_list : void 0 : void 0) || [];
        for (_n = 0, _len5 = _ref11.length; _n < _len5; _n++) {
          v = _ref11[_n];
          type_jl.push(translate_type(v, ctx));
        }
        tmp_var = "tmp_" + (ctx.tmp_idx++);
        call_expr = "" + fn + "(" + (arg_list.join(', ')) + ")";
        if (is_pure && type_jl.length === 0) {
          perr(root);
          throw new Error("Bad call of pure function that returns nothing");
        }
        if (type_jl.length === 1) {
          ctx.sink_list.push("const " + tmp_var + " : " + type_jl[0] + " = " + call_expr);
        } else {
          ctx.sink_list.push("const " + tmp_var + " : (" + (type_jl.join(' * ')) + ") = " + call_expr);
        }
        if (!is_pure) {
          ctx.sink_list.push("" + config.op_list + " := " + tmp_var + ".0");
          ctx.sink_list.push("" + config.contract_storage + " := " + tmp_var + ".1");
          return ctx.trim_expr = "" + tmp_var + ".2";
        } else {
          return ctx.trim_expr = "" + tmp_var;
        }
        break;
      case "Type_cast":
        target_type = translate_type(root.target_type, ctx);
        t = walk(root.t, ctx);
        if (t === "" && target_type === "address") {
          return "self_address";
        }
        if (target_type === "int") {
          return "int(abs(" + t + "))";
        } else if (target_type === "nat") {
          return "abs(" + t + ")";
        } else if (target_type === "address" && t === "0") {
          return type2default_value(root.target_type, ctx);
        } else if (target_type === "bytes" && ((_ref12 = root.t.type) != null ? _ref12.main : void 0) === "string") {
          return "bytes_pack(" + t + ")";
        } else if (target_type === "address" && (t === "0x0" || t === "0")) {
          return "(" + (JSON.stringify(config.default_address)) + " : " + target_type + ")";
        } else {
          return "(" + t + " : " + target_type + ")";
        }
        break;
      case "Comment":
        if (root.can_skip) {
          return "";
        } else {
          return "(* " + root.text + " *)";
        }
        break;
      case "Continue":
        return "(* CRITICAL WARNING continue is not supported *)";
      case "Break":
        return "(* CRITICAL WARNING break is not supported *)";
      case "Var_decl":
        name = root.name;
        if (root.name_translate) {
          name = translate_var_name(name, ctx);
        }
        type = translate_type(root.type, ctx);
        if (ctx.is_class_scope) {
          ctx.contract_var_hash[name] = root;
          return "" + name + " : " + type + ";";
        } else {
          if (root.assign_value) {
            val = walk(root.assign_value, ctx);
            if (config.bytes_type_hash.hasOwnProperty(root.type.main) && root.assign_value.type.main === "string" && root.assign_value.constructor.name === "Const") {
              val = string2bytes(root.assign_value.val);
            }
            if (config.bytes_type_hash.hasOwnProperty(root.type.main) && root.assign_value.type.main === "number" && root.assign_value.constructor.name === "Const") {
              val = number2bytes(root.assign_value.val);
            }
            return "const " + name + " : " + type + " = " + val;
          } else {
            return "const " + name + " : " + type + " = " + (type2default_value(root.type, ctx));
          }
        }
        break;
      case "Var_decl_multi":
        if (root.assign_value) {
          val = walk(root.assign_value, ctx);
          tmp_var = "tmp_" + (ctx.tmp_idx++);
          jl = [];
          type_list = [];
          _ref13 = root.list;
          for (idx = _o = 0, _len6 = _ref13.length; _o < _len6; idx = ++_o) {
            _var = _ref13[idx];
            name = _var.name;
            name = translate_var_name(name, ctx);
            type_list.push(type = translate_type(_var.type, ctx));
            jl.push("const " + name + " : " + type + " = " + tmp_var + "." + idx + ";");
          }
          return "const " + tmp_var + " : (" + (type_list.join(' * ')) + ") = " + val + ";\n" + (join_list(jl));
        } else {
          perr("CRITICAL WARNING Var_decl_multi with no assign value should be unreachable, but something goes wrong");
          perr("CRITICAL WARNING We can't guarantee that smart contract would work at all");
          module.warning_counter++;
          jl = [];
          _ref14 = root.list;
          for (_p = 0, _len7 = _ref14.length; _p < _len7; _p++) {
            _var = _ref14[_p];
            name = _var.name;
            name = translate_var_name(name, ctx);
            type = translate_type(root.type, ctx);
            jl.push("const " + name + " : " + type + " = " + (type2default_value(_var.type, ctx)));
          }
          return jl.join("\n");
        }
        break;
      case "Throw":
        if (root.t) {
          t = walk(root.t, ctx);
          return "failwith(" + t + ")";
        } else {
          return 'failwith("throw")';
        }
        break;
      case "Ret_multi":
        jl = [];
        _ref15 = root.t_list;
        for (idx = _q = 0, _len8 = _ref15.length; _q < _len8; idx = ++_q) {
          v = _ref15[idx];
          jl.push(walk(v, ctx));
        }
        return "with (" + (jl.join(', ')) + ")";
      case "If":
        cond = walk(root.cond, ctx);
        if (!last_bracket_state) {
          cond = "(" + cond + ")";
        }
        t = walk(root.t, ctx);
        f = walk(root.f, ctx);
        return "if " + cond + " then " + t + " else " + f + ";";
      case "While":
        cond = walk(root.cond, ctx);
        if (!last_bracket_state) {
          cond = "(" + cond + ")";
        }
        scope = walk(root.scope, ctx);
        return "while " + cond + " " + scope + ";";
      case "PM_switch":
        cond = walk(root.cond, ctx);
        ctx = ctx.mk_nest();
        jl = [];
        _ref16 = root.scope.list;
        for (_r = 0, _len9 = _ref16.length; _r < _len9; _r++) {
          _case = _ref16[_r];
          ctx.type_decl_hash[_case.var_decl.type.main] = _case.var_decl;
          case_scope = walk(_case.scope, ctx);
          jl.push("| " + _case.struct_name + "(" + _case.var_decl.name + ") -> " + case_scope);
        }
        return "case " + cond + " of\n" + (join_list(jl, '')) + "\nend";
      case "Fn_decl_multiret":
        orig_ctx = ctx;
        ctx = ctx.mk_nest();
        arg_jl = [];
        _ref17 = root.arg_name_list;
        for (idx = _s = 0, _len10 = _ref17.length; _s < _len10; idx = ++_s) {
          v = _ref17[idx];
          if (!(idx <= 1)) {
            v = translate_var_name(v, ctx);
          }
          type = translate_type(root.type_i.nest_list[idx], ctx);
          arg_jl.push("const " + v + " : " + type);
        }
        if (arg_jl.length === 0) {
          arg_jl.push("const " + config.reserved + "__unit : unit");
        }
        ret_jl = [];
        _ref18 = root.type_o.nest_list;
        for (_t = 0, _len11 = _ref18.length; _t < _len11; _t++) {
          v = _ref18[_t];
          type = translate_type(v, ctx);
          ret_jl.push("" + type);
        }
        name = root.name;
        if ((_ref19 = orig_ctx.current_class) != null ? _ref19.is_library : void 0) {
          name = "" + orig_ctx.current_class.name + "_" + name;
        }
        name = translate_var_name(name, ctx);
        body = walk(root.scope, ctx);
        return "function " + name + " (" + (arg_jl.join('; ')) + ") : (" + (ret_jl.join(' * ')) + ") is\n  " + (make_tab(body, '  '));
      case "Class_decl":
        if (root.need_skip) {
          return "";
        }
        if (root.is_interface) {
          return "";
        }
        orig_ctx = ctx;
        ctx.type_decl_hash[root.name] = root;
        prefix = "";
        if (ctx.parent && ctx.current_class && root.namespace_name) {
          ctx.parent.type_decl_hash["" + ctx.current_class.name + "." + root.name] = root;
          prefix = ctx.current_class.name;
        }
        ctx = ctx.mk_nest();
        ctx.current_class = root;
        ctx.is_class_scope = true;
        field_decl_jl = [];
        _ref20 = root.scope.list;
        for (_u = 0, _len12 = _ref20.length; _u < _len12; _u++) {
          v = _ref20[_u];
          switch (v.constructor.name) {
            case "Var_decl":
              field_decl_jl.push(walk(v, ctx));
              break;
            case "Fn_decl_multiret":
              ctx.contract_var_hash[v.name] = v;
              break;
            case "Enum_decl":
              "skip";
              break;
            case "Class_decl":
              code = walk(v, ctx);
              if (code) {
                ctx.sink_list.push(code);
              }
              break;
            case "Comment":
              ctx.sink_list.push(walk(v, ctx));
              break;
            case "Event_decl":
              ctx.sink_list.push(walk(v, ctx));
              break;
            default:
              throw new Error("unknown v.constructor.name " + v.constructor.name);
          }
        }
        jl = [];
        jl.append(ctx.sink_list);
        ctx.sink_list.clear();
        _ref21 = root.scope.list;
        for (_v = 0, _len13 = _ref21.length; _v < _len13; _v++) {
          v = _ref21[_v];
          switch (v.constructor.name) {
            case "Var_decl":
              "skip";
              break;
            case "Fn_decl_multiret":
            case "Enum_decl":
              jl.push(walk(v, ctx));
              break;
            case "Class_decl":
            case "Comment":
            case "Event_decl":
              "skip";
              break;
            default:
              throw new Error("unknown v.constructor.name " + v.constructor.name);
          }
        }
        if (root.is_contract || root.is_library) {
          orig_ctx.storage_sink_list.append(field_decl_jl);
        } else {
          name = root.name;
          if (prefix) {
            name = "" + prefix + "_" + name;
          }
          name = translate_var_name(name, ctx);
          ctx.type_decl_sink_list.push({
            name: name,
            field_decl_jl: field_decl_jl
          });
        }
        return jl.join("\n\n");
      case "Enum_decl":
        jl = [];
        ctx.type_decl_hash[root.name] = root;
        _ref22 = root.value_list;
        for (_w = 0, _len14 = _ref22.length; _w < _len14; _w++) {
          v = _ref22[_w];
          ctx.contract_var_hash[v.name] = v;
          aux = "";
          if (v.type) {
            type = translate_type(v.type, ctx);
            aux = " of " + (translate_var_name(type, ctx));
          }
          jl.push("| " + v.name + aux);
        }
        return "type " + (translate_var_name(root.name, ctx)) + " is\n  " + (join_list(jl, '  ')) + ";";
      case "Ternary":
        cond = walk(root.cond, ctx);
        t = walk(root.t, ctx);
        f = walk(root.f, ctx);
        return "(case " + cond + " of | True -> " + t + " | False -> " + f + " end)";
      case "New":
        arg_list = [];
        _ref23 = root.arg_list;
        for (_x = 0, _len15 = _ref23.length; _x < _len15; _x++) {
          v = _ref23[_x];
          arg_list.push(walk(v, ctx));
        }
        args = "" + (join_list(arg_list, ', '));
        translated_type = translate_type(root.cls, ctx);
        if (root.cls.main === "array") {
          return "map end (* args: " + args + " *)";
        } else if (translated_type === "bytes") {
          return "bytes_pack(unit) (* args: " + args + " *)";
        } else {
          return "" + translated_type + "(" + args + ")";
        }
        break;
      case "Tuple":
        arg_list = [];
        _ref24 = root.list;
        for (_y = 0, _len16 = _ref24.length; _y < _len16; _y++) {
          v = _ref24[_y];
          arg_list.push(walk(v, ctx));
        }
        return "(" + (arg_list.join(', ')) + ")";
      case "Array_init":
        arg_list = [];
        _ref25 = root.list;
        for (_z = 0, _len17 = _ref25.length; _z < _len17; _z++) {
          v = _ref25[_z];
          arg_list.push(walk(v, ctx));
        }
        decls = [];
        for (i = _aa = 0, _len18 = arg_list.length; _aa < _len18; i = ++_aa) {
          arg = arg_list[i];
          decls.push("" + i + "n -> " + arg + ";");
        }
        return "map\n  " + (join_list(decls, '  ')) + "\nend";
      case "Event_decl":
        return "(* EventDefinition " + root.name + " *)";
      default:
        if (ctx.next_gen != null) {
          return ctx.next_gen(root, ctx);
        } else {
          perr(root);
          throw new Error("Unknown root.constructor.name " + root.constructor.name);
        }
    }
  };

  this.gen = function(root, opt) {
    var ctx;
    if (opt == null) {
      opt = {};
    }
    ctx = new module.Gen_context;
    ctx.next_gen = opt.next_gen;
    return walk(root, ctx);
  };

}).call(window.translate_ligo = {});

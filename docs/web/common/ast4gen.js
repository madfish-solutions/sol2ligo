// Generated by IcedCoffeeScript 108.0.12
(function() {
  var  module, str_list, table, type_actualize, type_validate, v, void_type, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  
  module = this;

  void_type = new Type("void");

  this.type_actualize = type_actualize = function(t, root) {
    var walk;
    t = t.clone();
    walk = function(_t) {
      var idx, k, reg_ret, v, _i, _len, _ref, _ref1, _skip;
      if (reg_ret = /^_(\d+)$/.exec(_t.main)) {
        _skip = reg_ret[0], idx = reg_ret[1];
        if (!root.nest_list[idx]) {

          /* !pragma coverage-skip-block */
          throw new Error("can't resolve " + _t + " because root type '" + root + "' cas no nest_list[" + idx + "]");
        }
        return root.nest_list[idx].clone();
      }
      _ref = _t.nest_list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        _t.nest_list[k] = walk(v);
      }
      _ref1 = _t.field_hash;
      for (k in _ref1) {
        v = _ref1[k];

        /* !pragma coverage-skip-block */
        _t.field_hash[k] = walk(v);
      }
      return _t;
    };
    return walk(t);
  };

  type_validate = function(t, ctx) {
    var k, v, _i, _len, _ref, _ref1;
    if (!t) {
      throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". type is missing");
    }
    switch (t.main) {
      case "void":
      case "int":
      case "float":
      case "string":
      case "bool":
        if (t.nest_list.length !== 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have nest_list");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "array":
      case "hash_int":
        if (t.nest_list.length !== 1) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 1");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "hash":
        if (t.nest_list.length !== 1) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 1");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        break;
      case "struct":
        if (t.nest_list.length !== 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have nest_list 0");
        }
        break;
      case "function":
        if (t.nest_list.length === 0) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " must have at least nest_list 1 (ret type)");
        }
        if (0 !== h_count(t.field_hash)) {
          throw new Error("Type validation error line=" + this.line + " pos=" + this.pos + ". " + t.main + " can't have field_hash");
        }
        "";
        break;
      default:
        if (!ctx.check_type(t.main)) {
          throw new Error("unknown type '" + t + "'");
        }
    }
    _ref = t.nest_list;
    for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
      v = _ref[k];
      type_validate(v, ctx);
    }
    _ref1 = t.field_hash;
    for (k in _ref1) {
      v = _ref1[k];
      type_validate(v, ctx);
    }
  };

  wrap = function(_prepared_field2type) {
    var ret;
    ret = new module.Class_decl;
    ret._prepared_field2type = _prepared_field2type;
    return ret;
  };

  this.default_var_hash_gen = function() {
    var ret;
    return ret = {
      "true": new Type("bool"),
      "false": new Type("bool")
    };
  };

  this.default_type_hash_gen = function() {
    var ret;
    return ret = {
      "array": wrap({
        remove_idx: new Type("function<void, int>"),
        length_get: new Type("function<int>"),
        length_set: new Type("function<void, int>"),
        pop: new Type("function<_0>"),
        push: new Type("function<void,_0>"),
        slice: new Type("function<array<_0>,int,int>"),
        remove: new Type("function<void,_0>"),
        idx: new Type("function<int,_0>"),
        has: new Type("function<bool,_0>"),
        append: new Type("function<void,array<_0>>"),
        clone: new Type("function<array<_0>>"),
        sort_i: new Type("function<void,function<int,_0,_0>>"),
        sort_f: new Type("function<void,function<float,_0,_0>>"),
        sort_by_i: new Type("function<void,function<int,_0>>"),
        sort_by_f: new Type("function<void,function<float,_0>>"),
        sort_by_s: new Type("function<void,function<string,_0>>")
      }),
      "hash_int": wrap({
        add: new Type("function<void,int,_0>"),
        remove_idx: new Type("function<void,int>"),
        idx: new Type("function<_0,int>")
      })
    };
  };

  this.Validation_context = (function() {
    Validation_context.prototype.parent = null;

    Validation_context.prototype.executable = false;

    Validation_context.prototype.breakable = false;

    Validation_context.prototype.returnable = false;

    Validation_context.prototype.type_hash = {};

    Validation_context.prototype.var_hash = {};

    Validation_context.prototype.line = 0;

    Validation_context.prototype.pos = 0;

    function Validation_context() {
      this.type_hash = module.default_type_hash_gen();
      this.var_hash = module.default_var_hash_gen();
    }

    Validation_context.prototype.seek_non_executable_parent = function() {
      if (this.executable) {
        return this.parent.seek_non_executable_parent();
      } else {
        return this;
      }
    };

    Validation_context.prototype.mk_nest = function(pass_breakable) {
      var ret;
      ret = new module.Validation_context;
      ret.parent = this;
      ret.returnable = this.returnable;
      ret.executable = this.executable;
      if (pass_breakable) {
        ret.breakable = this.breakable;
      }
      return ret;
    };

    Validation_context.prototype.check_type = function(id) {
      var found;
      if (found = this.type_hash[id]) {
        return found;
      }
      if (this.parent) {
        return this.parent.check_type(id);
      }
      return null;
    };

    Validation_context.prototype.check_id = function(id) {
      var found;
      if (found = this.var_hash[id]) {
        return found;
      }
      if (this.parent) {
        return this.parent.check_id(id);
      }
      return null;
    };

    Validation_context.prototype.check_id_decl = function(id) {
      return this.var_hash[id];
    };

    return Validation_context;

  })();

  this.Const = (function() {
    function Const() {}

    Const.prototype.val = "";

    Const.prototype.type = null;

    Const.prototype.line = 0;

    Const.prototype.pos = 0;

    Const.prototype.validate = function(ctx) {
      var val, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      switch (this.type.main) {
        case "bool":
          if ((_ref = this.val) !== "true" && _ref !== "false") {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be bool");
          }
          break;
        case "int":
          if (parseInt(this.val).toString() !== this.val) {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be int");
          }
          break;
        case "float":
          val = this.val;
          val = val.replace(/\.0+$/, "");
          val = val.replace(/e(\d)/i, "e+$1");
          if (parseFloat(val).toString() !== val) {
            throw new Error("Const validation error line=" + this.line + " pos=" + this.pos + ". '" + this.val + "' can't be float");
          }
          break;
        case "string":
          "nothing";
          break;
        default:
          throw new Error("can't implement constant type '" + this.type + "'");
      }
    };

    Const.prototype.clone = function() {
      var ret;
      ret = new module.Const;
      ret.val = this.val;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Const;

  })();

  this.Array_init = (function() {
    Array_init.prototype.list = [];

    Array_init.prototype.type = null;

    Array_init.prototype.line = 0;

    Array_init.prototype.pos = 0;

    function Array_init() {
      this.list = [];
    }

    Array_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _i, _len, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "array") {
        throw new Error("Array_init validation error line=" + this.line + " pos=" + this.pos + ". type must be array but '" + this.type + "' found");
      }
      cmp_type = this.type.nest_list[0];
      _ref = this.list;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        v.validate(ctx);
        if (!v.type.cmp(cmp_type)) {
          throw new Error("Array_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Array_init.prototype.clone = function() {
      var ret, v, _i, _len, _ref;
      ret = new module.Array_init;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret.list.push(v.clone());
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Array_init;

  })();

  this.Hash_init = (function() {
    Hash_init.prototype.hash = {};

    Hash_init.prototype.type = null;

    Hash_init.prototype.line = 0;

    Hash_init.prototype.pos = 0;

    function Hash_init() {
      this.hash = {};
    }

    Hash_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _ref, _ref1;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "hash") {
        throw new Error("Hash_init validation error line=" + this.line + " pos=" + this.pos + ". type must be hash but '" + this.type + "' found");
      }
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        v.validate(ctx);
      }
      cmp_type = this.type.nest_list[0];
      _ref1 = this.hash;
      for (k in _ref1) {
        v = _ref1[k];
        if (!v.type.cmp(cmp_type)) {
          throw new Error("Hash_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Hash_init.prototype.clone = function() {
      var k, ret, v, _ref;
      ret = new module.Hash_init;
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        ret.hash[k] = v.clone();
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Hash_init;

  })();

  this.Struct_init = (function() {
    Struct_init.prototype.hash = {};

    Struct_init.prototype.type = null;

    Struct_init.prototype.line = 0;

    Struct_init.prototype.pos = 0;

    function Struct_init() {
      this.hash = {};
    }

    Struct_init.prototype.validate = function(ctx) {
      var cmp_type, k, v, _ref;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "struct") {
        throw new Error("Struct_init validation error line=" + this.line + " pos=" + this.pos + ". type must be struct but '" + this.type + "' found");
      }
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        v.validate(ctx);
        if (!v.type.cmp(cmp_type = this.type.field_hash[k])) {
          throw new Error("Struct_init validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' must be type '" + cmp_type + "' but '" + v.type + "' found");
        }
      }
    };

    Struct_init.prototype.clone = function() {
      var k, ret, v, _ref;
      ret = new module.Struct_init;
      _ref = this.hash;
      for (k in _ref) {
        v = _ref[k];
        ret.hash[k] = v.clone();
      }
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Struct_init;

  })();

  this.Var = (function() {
    function Var() {}

    Var.prototype.name = "";

    Var.prototype.type = null;

    Var.prototype.line = 0;

    Var.prototype.pos = 0;

    Var.prototype.validate = function(ctx) {
      var type, var_decl;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!/^[_a-z][_a-z0-9]*$/i.test(this.name)) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". invalid identifier '" + this.name + "'");
      }
      type_validate(this.type, ctx);
      var_decl = ctx.check_id(this.name);
      if (!var_decl) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". Id '" + this.name + "' not defined");
      }
      type = var_decl.type;
      if (!this.type.cmp(type)) {
        throw new Error("Var validation error line=" + this.line + " pos=" + this.pos + ". Var type !+ Var_decl type '" + this.type + "' != " + type);
      }
    };

    Var.prototype.clone = function() {
      var ret;
      ret = new module.Var;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Var;

  })();

  this.allowed_bin_op_hash = {
    ADD: true,
    SUB: true,
    MUL: true,
    DIV: true,
    DIV_INT: true,
    MOD: true,
    POW: true,
    BIT_AND: true,
    BIT_OR: true,
    BIT_XOR: true,
    BOOL_AND: true,
    BOOL_OR: true,
    BOOL_XOR: true,
    SHR: true,
    SHL: true,
    LSR: true,
    ASSIGN: true,
    ASS_ADD: true,
    ASS_SUB: true,
    ASS_MUL: true,
    ASS_DIV: true,
    ASS_DIV_INT: true,
    ASS_MOD: true,
    ASS_POW: true,
    ASS_SHR: true,
    ASS_SHL: true,
    ASS_LSR: true,
    ASS_BIT_AND: true,
    ASS_BIT_OR: true,
    ASS_BIT_XOR: true,
    ASS_BOOL_AND: true,
    ASS_BOOL_OR: true,
    ASS_BOOL_XOR: true,
    EQ: true,
    NE: true,
    GT: true,
    LT: true,
    GTE: true,
    LTE: true,
    INDEX_ACCESS: true
  };

  this.assign_bin_op_hash = {
    ASSIGN: true,
    ASS_ADD: true,
    ASS_SUB: true,
    ASS_MUL: true,
    ASS_DIV: true,
    ASS_MOD: true,
    ASS_POW: true,
    ASS_SHR: true,
    ASS_SHL: true,
    ASS_LSR: true,
    ASS_BIT_AND: true,
    ASS_BIT_OR: true,
    ASS_BIT_XOR: true,
    ASS_BOOL_AND: true,
    ASS_BOOL_OR: true,
    ASS_BOOL_XOR: true
  };

  this.bin_op_ret_type_hash_list = {
    DIV: [["int", "int", "float"], ["int", "float", "float"], ["float", "int", "float"], ["float", "float", "float"]],
    DIV_INT: [["int", "int", "int"], ["int", "float", "int"], ["float", "int", "int"], ["float", "float", "int"]]
  };

  _ref = "ADD SUB MUL POW".split(/\s+/g);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"], ["int", "float", "float"], ["float", "int", "float"], ["float", "float", "float"]];
  }

  _ref1 = "MOD BIT_AND BIT_OR BIT_XOR SHR SHL LSR".split(/\s+/g);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    v = _ref1[_j];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"]];
  }

  _ref2 = "BOOL_AND BOOL_OR BOOL_XOR".split(/\s+/g);
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    v = _ref2[_k];
    this.bin_op_ret_type_hash_list[v] = [["bool", "bool", "bool"]];
  }

  this.bin_op_ret_type_hash_list.ADD.push(["string", "string", "string"]);

  this.bin_op_ret_type_hash_list.MUL.push(["string", "int", "string"]);

  _ref3 = "ASSIGN".split(/\s+/g);
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    v = _ref3[_l];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "int"], ["bool", "bool", "bool"], ["float", "float", "float"], ["string", "string", "string"]];
  }

  _ref4 = "EQ NE GT LT GTE LTE".split(/\s+/g);
  for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
    v = _ref4[_m];
    this.bin_op_ret_type_hash_list[v] = [["int", "int", "bool"], ["float", "float", "bool"], ["string", "string", "bool"]];
  }

  str_list = "ADD\nSUB\nMUL\nDIV\nDIV_INT\nMOD\nPOW\n\nSHR\nSHL\nLSR\n\nBIT_AND \nBIT_OR  \nBIT_XOR \n\nBOOL_AND\nBOOL_OR \nBOOL_XOR";

  _ref5 = str_list.split(/\s+/g);
  for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
    v = _ref5[_n];
    table = this.bin_op_ret_type_hash_list[v];
    table = table.filter(function(row) {
      return row[0] === row[2];
    });
    table = table.map(function(t) {
      return t.clone();
    });
    this.bin_op_ret_type_hash_list["ASS_" + v] = table;
  }

  this.Bin_op = (function() {
    function Bin_op() {}

    Bin_op.prototype.a = null;

    Bin_op.prototype.b = null;

    Bin_op.prototype.op = null;

    Bin_op.prototype.type = null;

    Bin_op.prototype.line = 0;

    Bin_op.prototype.pos = 0;

    Bin_op.prototype.validate = function(ctx) {
      var found, list, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.a) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". a missing");
      }
      this.a.validate(ctx);
      if (!this.b) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". b missing");
      }
      this.b.validate(ctx);
      type_validate(this.type, ctx);
      if (!module.allowed_bin_op_hash[this.op]) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Invalid op '" + this.op + "'");
      }
      found = false;
      if (list = module.bin_op_ret_type_hash_list[this.op]) {
        for (_o = 0, _len6 = list.length; _o < _len6; _o++) {
          v = list[_o];
          if (v[0] !== this.a.type.toString()) {
            continue;
          }
          if (v[1] !== this.b.type.toString()) {
            continue;
          }
          found = true;
          if (v[2] !== this.type.toString()) {
            throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " with types " + this.a.type + " " + this.b.type + " should produce type " + v[2] + " but " + this.type + " found");
          }
          break;
        }
      }
      if (!found) {
        if (this.op === "ASSIGN") {
          if (this.a.type.cmp(this.b.type)) {
            if (this.a.type.cmp(this.type)) {
              found = true;
            } else {
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". " + this.op + " a=b=[" + this.a.type + "] must have return type '" + this.a.type + "'");
            }
          }
        } else if ((_ref6 = this.op) === "EQ" || _ref6 === "NE") {
          if (this.a.type.cmp(this.b.type)) {
            if (this.type.main === "bool") {
              found = true;
            } else {
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". " + this.op + " a=b=[" + this.a.type + "] must have return type bool");
            }
          }
        } else if (this.op === "INDEX_ACCESS") {
          switch (this.a.type.main) {
            case "string":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.main === "string") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be string");
              }
              break;
            case "array":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            case "hash":
              if (this.b.type.main === "string") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be string");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            case "hash_int":
              if (this.b.type.main === "int") {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be int");
              }
              if (this.type.cmp(this.a.type.nest_list[0])) {
                found = true;
              } else {
                throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". bin_op=" + this.op + " " + this.a.type + " " + this.b.type + " ret type must be " + this.a.type.nest_list[0] + " but " + this.type + " found");
              }
              break;
            default:
              throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply bin_op=" + this.op + " to " + this.a.type + " " + this.b.type);
          }
        }
      }
      if (!found) {
        throw new Error("Bin_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply bin_op=" + this.op + " to " + this.a.type + " " + this.b.type);
      }
    };

    Bin_op.prototype.clone = function() {
      var ret;
      ret = new module.Bin_op;
      ret.a = this.a.clone();
      ret.b = this.b.clone();
      ret.op = this.op;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Bin_op;

  })();

  this.allowed_un_op_hash = {
    INC_RET: true,
    RET_INC: true,
    DEC_RET: true,
    RET_DEC: true,
    BOOL_NOT: true,
    BIT_NOT: true,
    MINUS: true,
    PLUS: true,
    IS_NOT_NULL: true
  };

  this.un_op_ret_type_hash_list = {
    INC_RET: [["int", "int"]],
    RET_INC: [["int", "int"]],
    DEC_RET: [["int", "int"]],
    RET_DEC: [["int", "int"]],
    BOOL_NOT: [["bool", "bool"]],
    BIT_NOT: [["int", "int"]],
    MINUS: [["int", "int"], ["float", "float"]],
    PLUS: [["string", "float"]]
  };

  this.Un_op = (function() {
    function Un_op() {}

    Un_op.prototype.a = null;

    Un_op.prototype.op = null;

    Un_op.prototype.type = null;

    Un_op.prototype.line = 0;

    Un_op.prototype.pos = 0;

    Un_op.prototype.validate = function(ctx) {
      var found, list, _len6, _o;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.a) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". a missing");
      }
      this.a.validate(ctx);
      type_validate(this.type, ctx);
      if (!module.allowed_un_op_hash[this.op]) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". Invalid op '" + this.op + "'");
      }
      list = module.un_op_ret_type_hash_list[this.op];
      found = false;
      if (list) {
        for (_o = 0, _len6 = list.length; _o < _len6; _o++) {
          v = list[_o];
          if (v[0] !== this.a.type.toString()) {
            continue;
          }
          found = true;
          if (v[1] !== this.type.toString()) {
            throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". un_op=" + this.op + " with type " + this.a.type + " should produce type " + v[1] + " but " + this.type + " found");
          }
          break;
        }
      }
      if (this.op === "IS_NOT_NULL") {
        if (this.type.main !== "bool") {
          throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". un_op=" + this.op + " with type " + this.a.type + " should produce type bool but " + this.type + " found");
        }
        found = true;
      }
      if (!found) {
        throw new Error("Un_op validation error line=" + this.line + " pos=" + this.pos + ". Can't apply un_op=" + this.op + " to " + this.a.type);
      }
    };

    Un_op.prototype.clone = function() {
      var ret;
      ret = new module.Un_op;
      ret.a = this.a.clone();
      ret.op = this.op;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Un_op;

  })();

  this.Field_access = (function() {
    function Field_access() {}

    Field_access.prototype.t = null;

    Field_access.prototype.name = "";

    Field_access.prototype.type = null;

    Field_access.prototype.line = 0;

    Field_access.prototype.pos = 0;

    Field_access.prototype.validate = function(ctx) {
      var class_decl, nest_type, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.t) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Missing target");
      }
      this.t.validate(ctx);
      if (!this.name) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Missing name");
      }
      type_validate(this.type, ctx);
      if (this.name === "new") {
        if ((_ref6 = this.t.type.main) === "bool" || _ref6 === "int" || _ref6 === "float" || _ref6 === "string") {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing field '" + this.name + "' in '" + this.t.type + "'.");
        }
        nest_type = new Type("function");
        nest_type.nest_list[0] = this.t.type;
      } else if (this.t.type.main === "struct") {
        if (!(nest_type = this.t.type.field_hash[this.name])) {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing field '" + this.name + "' in '" + this.t.type + "'. Possible keys [" + (Object.keys(this.t.type.field_hash).join(', ')) + "]");
        }
      } else {
        class_decl = ctx.check_type(this.t.type.main);
        if (!(nest_type = class_decl._prepared_field2type[this.name])) {
          throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to missing class field '" + this.name + "' in '" + this.t.type + "'. Possible keys [" + (Object.keys(class_decl._prepared_field2type).join(', ')) + "]");
        }
      }
      nest_type = type_actualize(nest_type, this.t.type);
      if (!this.type.cmp(nest_type)) {
        throw new Error("Field_access validation error line=" + this.line + " pos=" + this.pos + ". Access to field '" + this.name + "' with type '" + nest_type + "' but result '" + this.type + "'");
      }
    };

    Field_access.prototype.clone = function() {
      var ret;
      ret = new module.Field_access;
      ret.t = this.t.clone();
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Field_access;

  })();

  this.Fn_call = (function() {
    Fn_call.prototype.fn = null;

    Fn_call.prototype.arg_list = [];

    Fn_call.prototype.splat_fin = false;

    Fn_call.prototype.type = null;

    Fn_call.prototype.line = 0;

    Fn_call.prototype.pos = 0;

    function Fn_call() {
      this.arg_list = [];
    }

    Fn_call.prototype.validate = function(ctx) {
      var arg, k, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.fn) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". fn missing");
      }
      this.fn.validate(ctx);
      if (this.fn.type.main !== "function") {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Can't call type '@fn.type'. You can call only function");
      }
      if (!this.type.cmp(void_type)) {
        type_validate(this.type, ctx);
      }
      if (!this.type.cmp(this.fn.type.nest_list[0])) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Return type and function decl return type doesn't match " + this.fn.type.nest_list[0] + " != " + this.type);
      }
      if (this.fn.type.nest_list.length - 1 !== this.arg_list.length) {
        throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". Expected arg count=" + (this.fn.type.nest_list.length - 1) + " found=" + this.arg_list.length);
      }
      _ref6 = this.arg_list;
      for (k = _o = 0, _len6 = _ref6.length; _o < _len6; k = ++_o) {
        arg = _ref6[k];
        arg.validate(ctx);
        if (!this.fn.type.nest_list[k + 1].cmp(arg.type)) {
          throw new Error("Fn_call validation error line=" + this.line + " pos=" + this.pos + ". arg[" + k + "] type mismatch. Expected=" + this.fn.type.nest_list[k + 1] + " found=" + arg.type);
        }
      }
    };

    Fn_call.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Fn_call;
      ret.fn = this.fn.clone();
      _ref6 = this.arg_list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        ret.arg_list.push(v.clone());
      }
      ret.splat_fin = this.splat_fin;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Fn_call;

  })();

  this.Scope = (function() {
    Scope.prototype.list = [];

    Scope.prototype.need_nest = true;

    Scope.prototype.line = 0;

    Scope.prototype.pos = 0;

    function Scope() {
      this.list = [];
    }

    Scope.prototype.validate = function(ctx) {
      var ctx_nest, stmt, _len6, _len7, _o, _p, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (this.need_nest) {
        ctx_nest = ctx.mk_nest(true);
      } else {
        ctx_nest = ctx;
      }
      _ref6 = this.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        stmt = _ref6[_o];
        if (typeof stmt.register === "function") {
          stmt.register(ctx_nest);
        }
      }
      _ref7 = this.list;
      for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
        stmt = _ref7[_p];
        stmt.validate(ctx_nest);
      }
    };

    Scope.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Scope;
      _ref6 = this.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        ret.list.push(v.clone());
      }
      ret.need_nest = this.need_nest;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Scope;

  })();

  this.If = (function() {
    If.prototype.cond = null;

    If.prototype.t = null;

    If.prototype.f = null;

    If.prototype.line = 0;

    If.prototype.pos = 0;

    function If() {
      this.t = new module.Scope;
      this.f = new module.Scope;
    }

    If.prototype.validate = function(ctx) {
      var _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if ((_ref6 = this.cond.type.main) !== "bool" && _ref6 !== "int") {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". cond must be bool or int but found '" + this.cond.type + "'");
      }
      this.t.validate(ctx);
      this.f.validate(ctx);
      if (this.t.list.length === 0) {
        perr("Warning. If empty true body");
      }
      if (this.t.list.length === 0 && this.f.list.length === 0) {
        throw new Error("If validation error line=" + this.line + " pos=" + this.pos + ". Empty true and false sections");
      }
    };

    If.prototype.clone = function() {
      var ret;
      ret = new module.If;
      ret.cond = this.cond.clone();
      ret.t = this.t.clone();
      ret.f = this.f.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return If;

  })();

  this.Switch = (function() {
    Switch.prototype.cond = null;

    Switch.prototype.hash = {};

    Switch.prototype.f = null;

    Switch.prototype.line = 0;

    Switch.prototype.pos = 0;

    function Switch() {
      this.hash = {};
      this.f = new module.Scope;
    }

    Switch.prototype.validate = function(ctx) {
      var k, _ref6, _ref7, _ref8;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if (0 === h_count(this.hash)) {
        throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". no when conditions found");
      }
      switch (this.cond.type.main) {
        case "int":
          _ref6 = this.hash;
          for (k in _ref6) {
            v = _ref6[k];
            if (parseInt(k).toString() !== k || !isFinite(k)) {
              throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". key '" + k + "' can't be int");
            }
          }
          break;
        case "string":
          "nothing";
          break;
        default:
          throw new Error("Switch validation error line=" + this.line + " pos=" + this.pos + ". Can't implement switch for condition type '" + this.cond.type + "'");
      }
      _ref7 = this.hash;
      for (k in _ref7) {
        v = _ref7[k];
        v.validate(ctx.mk_nest());
      }
      if ((_ref8 = this.f) != null) {
        _ref8.validate(ctx);
      }
    };

    Switch.prototype.clone = function() {
      var k, ret, _ref6;
      ret = new module.Switch;
      ret.cond = this.cond.clone();
      _ref6 = this.hash;
      for (k in _ref6) {
        v = _ref6[k];
        ret.hash[k] = v.clone();
      }
      ret.f = this.f.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Switch;

  })();

  this.Loop = (function() {
    Loop.prototype.scope = null;

    Loop.prototype.line = 0;

    Loop.prototype.pos = 0;

    function Loop() {
      this.scope = new module.Scope;
    }

    Loop.prototype.validate = function(ctx) {
      var ctx_nest, found, walk;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
      found = false;
      walk = function(t) {
        var _len6, _o, _ref6;
        switch (t.constructor.name) {
          case "Scope":
            _ref6 = t.list;
            for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
              v = _ref6[_o];
              walk(v);
            }
            break;
          case "If":
            walk(t.t);
            walk(t.f);
            break;
          case "Break":
          case "Ret":
            found = true;
        }
      };
      walk(this.scope);
      if (!found) {
        throw new Error("Loop validation error line=" + this.line + " pos=" + this.pos + ". Break or Ret not found");
      }
    };

    Loop.prototype.clone = function() {
      var ret;
      ret = new module.Loop;
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Loop;

  })();

  this.Break = (function() {
    Break.prototype.line = 0;

    Break.prototype.pos = 0;

    function Break() {}

    Break.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!ctx.breakable) {
        throw new Error("Break validation error line=" + this.line + " pos=" + this.pos + ". You can't use break outside loop, while");
      }
    };

    Break.prototype.clone = function() {
      var ret;
      ret = new module.Break;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Break;

  })();

  this.Continue = (function() {
    Continue.prototype.line = 0;

    Continue.prototype.pos = 0;

    function Continue() {}

    Continue.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!ctx.breakable) {
        throw new Error("Continue validation error line=" + this.line + " pos=" + this.pos + ". You can't use continue outside loop, while");
      }
    };

    Continue.prototype.clone = function() {
      var ret;
      ret = new module.Continue;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Continue;

  })();

  this.While = (function() {
    While.prototype.cond = null;

    While.prototype.scope = null;

    While.prototype.line = 0;

    While.prototype.pos = 0;

    function While() {
      this.scope = new module.Scope;
    }

    While.prototype.validate = function(ctx) {
      var ctx_nest, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.cond) {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". cond missing");
      }
      this.cond.validate(ctx);
      if ((_ref6 = this.cond.type.main) !== "bool" && _ref6 !== "int") {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". cond must be bool or int");
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
      if (this.scope.list.length === 0) {
        throw new Error("While validation error line=" + this.line + " pos=" + this.pos + ". Empty while is not allowed");
      }
    };

    While.prototype.clone = function() {
      var ret;
      ret = new module.While;
      ret.cond = this.cond.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return While;

  })();

  this.For_range = (function() {
    For_range.prototype.exclusive = true;

    For_range.prototype.i = null;

    For_range.prototype.a = null;

    For_range.prototype.b = null;

    For_range.prototype.step = null;

    For_range.prototype.scope = null;

    For_range.prototype.line = 0;

    For_range.prototype.pos = 0;

    function For_range() {
      this.scope = new module.Scope;
    }

    For_range.prototype.validate = function(ctx) {
      var ctx_nest, _ref10, _ref6, _ref7, _ref8, _ref9;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.i) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Iterator is missing");
      }
      if (!this.a) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a is missing");
      }
      if (!this.b) {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b is missing");
      }
      this.i.validate(ctx);
      this.a.validate(ctx);
      this.b.validate(ctx);
      if ((_ref6 = this.step) != null) {
        _ref6.validate(ctx);
      }
      if ((_ref7 = this.i.type.main) !== "int" && _ref7 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Iterator should be type int or float but '" + this.i.type + "' found");
      }
      if ((_ref8 = this.a.type.main) !== "int" && _ref8 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a should be type int or float but '" + this.a.type + "' found");
      }
      if ((_ref9 = this.b.type.main) !== "int" && _ref9 !== "float") {
        throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b should be type int or float but '" + this.b.type + "' found");
      }
      if (this.step) {
        if ((_ref10 = this.step.type.main) !== "int" && _ref10 !== "float") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Step should be type int or float but '" + this.step.type + "' found");
        }
      }
      if (this.i.type.main === "int") {
        if (this.a.type.main !== "int") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range a should be type int because iterator is int but '" + this.a.type + "' found");
        }
        if (this.b.type.main !== "int") {
          throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Range b should be type int because iterator is int but '" + this.b.type + "' found");
        }
        if (this.step) {
          if (this.step.type.main !== "int") {
            throw new Error("For_range validation error line=" + this.line + " pos=" + this.pos + ". Step should be type int because iterator is int but '" + this.step.type + "' found");
          }
        }
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
    };

    For_range.prototype.clone = function() {
      var ret;
      ret = new module.For_range;
      ret.exclusive = this.exclusive;
      ret.i = this.i.clone();
      ret.a = this.a.clone();
      ret.b = this.b.clone();
      if (this.step) {
        ret.step = this.step.clone();
      }
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return For_range;

  })();

  this.For_col = (function() {
    For_col.prototype.k = null;

    For_col.prototype.v = null;

    For_col.prototype.t = null;

    For_col.prototype.scope = null;

    For_col.prototype.line = 0;

    For_col.prototype.pos = 0;

    function For_col() {
      this.scope = new module.Scope;
    }

    For_col.prototype.validate = function(ctx) {
      var ctx_nest, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.t) {
        throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Target is missing");
      }
      if (!this.k && !this.v) {
        throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key and value is missing");
      }
      this.t.validate(ctx);
      if ((_ref6 = this.k) != null) {
        _ref6.validate(ctx);
      }
      if ((_ref7 = this.v) != null) {
        _ref7.validate(ctx);
      }
      switch (this.t.type.main) {
        case "array":
        case "hash_int":
          if (this.k) {
            if (this.k.type.main !== "int") {
              throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key must be int for array<t> target but found '" + this.k.type + "'");
            }
          }
          break;
        case "hash":
          if (this.k) {
            if (this.k.type.main !== "string") {
              throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Key must be string for hash<t> target but found '" + this.k.type + "'");
            }
          }
          break;
        default:
          throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". For_col accepts types array<t>, hash<t> and hash_int<t> but found '" + this.t.type + "'");
      }
      if (this.v) {
        if (!this.v.type.cmp(this.t.type.nest_list[0])) {
          throw new Error("For_col validation error line=" + this.line + " pos=" + this.pos + ". Value must be '" + this.t.type.nest_list[0] + "' but found '" + this.v.type + "'");
        }
      }
      ctx_nest = ctx.mk_nest();
      ctx_nest.breakable = true;
      this.scope.validate(ctx_nest);
    };

    For_col.prototype.clone = function() {
      var ret;
      ret = new module.For_col;
      ret.t = this.t.clone();
      if (this.v) {
        ret.v = this.v.clone();
      }
      if (this.k) {
        ret.k = this.k.clone();
      }
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return For_col;

  })();

  this.Ret = (function() {
    function Ret() {}

    Ret.prototype.t = null;

    Ret.prototype.line = 0;

    Ret.prototype.pos = 0;

    Ret.prototype.validate = function(ctx) {
      var return_type, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if ((_ref6 = this.t) != null) {
        _ref6.validate(ctx);
      }
      if (!ctx.returnable) {
        throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". ctx must be returnable");
      }
      return_type = ctx.check_id("$_return_type");
      if (this.t != null) {
        if (!this.t.type.cmp(return_type)) {
          throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". Ret type must be '" + return_type + "' but found '" + this.t.type + "'");
        }
      } else {
        if (return_type.main !== "void") {
          throw new Error("Ret validation error line=" + this.line + " pos=" + this.pos + ". Ret type must be '" + return_type + "' but found void (no return value)");
        }
      }
    };

    Ret.prototype.clone = function() {
      var ret;
      ret = new module.Ret;
      if (this.t) {
        ret.t = this.t.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Ret;

  })();

  this.Try = (function() {
    Try.prototype.t = null;

    Try.prototype.c = null;

    Try.prototype.exception_var_name = "";

    Try.prototype.line = 0;

    Try.prototype.pos = 0;

    function Try() {
      this.t = new module.Scope;
      this.c = new module.Scope;
    }

    Try.prototype.clone = function() {
      var ret;
      ret = new module.Try;
      ret.t = this.t.clone();
      ret.c = this.c.clone();
      ret.exception_var_name = this.exception_var_name;
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Try;

  })();

  this.Throw = (function() {
    function Throw() {}

    Throw.prototype.t = null;

    Throw.prototype.line = 0;

    Throw.prototype.pos = 0;

    Throw.prototype.clone = function() {
      var ret;
      ret = new module.Throw;
      if (this.t) {
        ret.t = this.t.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Throw;

  })();

  this.Var_decl = (function() {
    function Var_decl() {}

    Var_decl.prototype.name = "";

    Var_decl.prototype.type = null;

    Var_decl.prototype.size = null;

    Var_decl.prototype.assign_value = null;

    Var_decl.prototype.assign_value_list = null;

    Var_decl.prototype.line = 0;

    Var_decl.prototype.pos = 0;

    Var_decl.prototype.validate = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      type_validate(this.type, ctx);
      if (ctx.check_id_decl(this.name)) {
        throw new Error("Var_decl validation error line=" + this.line + " pos=" + this.pos + ". Redeclare '" + this.name + "'");
      }
      ctx.var_hash[this.name] = this;
    };

    Var_decl.prototype.clone = function() {
      var ret, _len6, _o, _ref6;
      ret = new module.Var_decl;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.size = this.size;
      if (this.assign_value) {
        ret.assign_value = this.assign_value.clone();
      }
      if (this.assign_value_list) {
        ret.assign_value_list = [];
        _ref6 = this.assign_value_list;
        for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
          v = _ref6[_o];
          ret.assign_value_list.push(v.clone());
        }
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Var_decl;

  })();

  this.Class_decl = (function() {
    Class_decl.prototype.name = "";

    Class_decl.prototype.scope = null;

    Class_decl.prototype._prepared_field2type = {};

    Class_decl.prototype.line = 0;

    Class_decl.prototype.pos = 0;

    function Class_decl() {
      this.scope = new module.Scope;
      this._prepared_field2type = {};
    }

    Class_decl.prototype.register = function(ctx) {
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (ctx.check_type(this.name)) {
        throw new Error("Already registered '" + this.name + "'");
      }
      ctx.type_hash[this.name] = this;
    };

    Class_decl.prototype.validate = function(ctx) {
      var ctx_nest, var_decl, _len6, _o, _ref6, _ref7;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.name) {
        throw new Error("Class_decl validation error line=" + this.line + " pos=" + this.pos + ". Class should have name");
      }
      this._prepared_field2type = {};
      _ref6 = this.scope.list;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        v = _ref6[_o];
        if ((_ref7 = v.constructor.name) !== "Var_decl" && _ref7 !== "Fn_decl") {
          throw new Error("Class_decl validation error line=" + this.line + " pos=" + this.pos + ". Only Var_decl and Fn_decl allowed at Class_decl, but '" + v.constructor.name + "' found");
        }
        this._prepared_field2type[v.name] = v.type;
      }
      ctx_nest = ctx.mk_nest();
      var_decl = new module.Var_decl;
      var_decl.name = "this";
      var_decl.type = new Type(this.name);
      ctx_nest.var_hash["this"] = var_decl;
      this.scope.validate(ctx_nest);
    };

    Class_decl.prototype.clone = function() {
      var k, ret, _ref6;
      ret = new module.Class_decl;
      ret.name = this.name;
      ret.scope = this.scope.clone();
      _ref6 = this._prepared_field2type;
      for (k in _ref6) {
        v = _ref6[k];
        ret._prepared_field2type[k] = v.clone();
      }
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Class_decl;

  })();

  this.Fn_decl = (function() {
    Fn_decl.prototype.is_closure = false;

    Fn_decl.prototype.name = "";

    Fn_decl.prototype.type = null;

    Fn_decl.prototype.arg_name_list = [];

    Fn_decl.prototype.scope = null;

    Fn_decl.prototype.line = 0;

    Fn_decl.prototype.pos = 0;

    function Fn_decl() {
      this.arg_name_list = [];
      this.scope = new module.Scope;
    }

    Fn_decl.prototype.validate = function(ctx) {
      var ctx_nest, decl, k, name, var_decl, _len6, _o, _ref6;
      if (ctx == null) {
        ctx = new module.Validation_context;
      }
      if (!this.name && !this.is_closure) {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". Function should have name");
      }
      type_validate(this.type, ctx);
      if (this.type.main !== "function") {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". Type must be function but '" + this.type + "' found");
      }
      if (this.type.nest_list.length - 1 !== this.arg_name_list.length) {
        throw new Error("Fn_decl validation error line=" + this.line + " pos=" + this.pos + ". @type.nest_list.length-1 != @arg_name_list " + (this.type.nest_list.length - 1) + " != " + this.arg_name_list.length);
      }
      if (this.is_closure) {
        ctx_nest = ctx.mk_nest();
      } else {
        ctx_nest = ctx.seek_non_executable_parent().mk_nest();
      }
      ctx_nest.executable = true;
      ctx_nest.returnable = true;
      _ref6 = this.arg_name_list;
      for (k = _o = 0, _len6 = _ref6.length; _o < _len6; k = ++_o) {
        name = _ref6[k];
        decl = new module.Var_decl;
        decl.name = name;
        decl.type = this.type.nest_list[1 + k];
        ctx_nest.var_hash[name] = decl;
      }
      ctx_nest.var_hash["$_return_type"] = this.type.nest_list[0];
      this.scope.validate(ctx_nest);
      var_decl = new module.Var_decl;
      var_decl.name = this.name;
      var_decl.type = this.type;
      ctx.var_hash[this.name] = var_decl;
    };

    Fn_decl.prototype.clone = function() {
      var ret;
      ret = new module.Fn_decl;
      ret.is_closure = this.is_closure;
      ret.name = this.name;
      if (this.type) {
        ret.type = this.type.clone();
      }
      ret.arg_name_list = this.arg_name_list.clone();
      ret.scope = this.scope.clone();
      ret.line = this.line;
      ret.pos = this.pos;
      return ret;
    };

    return Fn_decl;

  })();

}).call(window.ast4gen = {});
